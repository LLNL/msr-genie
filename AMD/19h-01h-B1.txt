#MSR0000_0010 [Time Stamp Counter] (Core::X86::Msr::TSC)
##Read-write,Volatile. Reset: 0000_0000_0000_0000h. The TSC uses a common reference for all sockets, cores and threads.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_0010"
	63:0	"TSC: time stamp counter. Read-write,Volatile. Reset: 0000_0000_0000_0000h. The TSC increments at the P0 frequency. The TSC counts at the same rate in all P-states, all C states, S0, or S1. A read of this MSR in guest mode is affected by Core::X86::Msr::TscRateMsr. The value (TSC/TSCRatio) is the TSC P0 frequency based value (as if TSCRatio == 1.0) when (TSCRatio != 1.0)."

#MSR0000_001B [APIC Base Address] (Core::X86::Msr::APIC_BAR)
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_001B"
	63:48	Reserved.
	47:12	"ApicBar[47:12]: APIC base address register. Read-write. Reset: 0_000F_EE00h. Specifies the base address, physical address [47:12], for the APICXX register set in xAPIC mode. See 2.1.14.2.1.2 [APIC Register Space]."
	11	"ApicEn: APIC enable. Read-write. Reset: 0. 0=Disable Local APIC. 1=Local APIC is enabled in xAPIC mode. See 2.1.14.2.1.2 [APIC Register Space]."
	10	"x2ApicEn: Extended APIC enable. Read-write. Reset: 0. 0=Disable Extended Local APIC. 1=Extended Local APIC is enabled in x2APIC mode."
	9	Reserved.
	8	"BSC: boot strap core. Read-write,Volatile. Reset: X. 0=The core is not the boot core of the BSP. 1=The core is the boot core of the BSP."
	7:0	Reserved.

#MSR0000_002A [Cluster ID] (Core::X86::Msr::EBL_CR_POWERON)
##Writes to this register result in a GP fault with error code 0.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_002A"
	63:18	Reserved.
	17:16	ClusterID. Read,Error-on-write. Reset: 0h. The field does not affect hardware.
	15:0	Reserved.

#MSR0000_0048 [Speculative Control] (Core::X86::Msr::SPEC_CTRL)
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_0048"
	63:8	Reserved.
	7	PSFD: Predictive Store Forwarding Disable. Read-write. Reset: 0. 1=Disable predictive store forwarding.
	6:3	Reserved.
	2	SSBD. Read-write. Reset: 0. Speculative Store Bypass Disable.
	1	STIBP. Read-write. Reset: 0. Single thread indirect branch predictor.
	0	IBRS. Read-write. Reset: 0. Indirect branch restriction speculation.

#MSR0000_0049 [Prediction Command] (Core::X86::Msr::PRED_CMD)
###"_ccd[7:0]_lthree0_core[7:0]; MSR0000_0049"
	63:1	Reserved.
	0	IBPB: indirect branch prediction barrier. Write-only,Error-on-read. Reset: 0. Supported if Core::X86::Cpuid::FeatureExtIdEbx[IBPB] == 1.

#MSR0000_008B [Patch Level] (Core::X86::Msr::PATCH_LEVEL)
##Read,Error-on-write,Volatile. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]; MSR0000_008B"
	63:32	Reserved.
	31:0	PatchLevel. Read,Error-on-write,Volatile. Reset: 0000_0000h. This returns an identification number for the microcode patch that has been loaded. If no patch has been loaded, this returns 0.

#MSR0000_00E7 [Max Performance Frequency Clock Count] (Core::X86::Msr::MPERF)
##Read-write,Volatile. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_00E7"
	63:0	"MPERF: maximum core clocks counter. Read-write,Volatile. Reset: 0000_0000_0000_0000h. Incremented by hardware at the P0 frequency while the core is in C0. This register does not increment when the core is in the stop-grant state. In combination with Core::X86::Msr::APERF, this is used to determine the effective frequency of the core. A read of this MSR in guest mode is affected by Core::X86::Msr::TscRateMsr. This field uses software P-state numbering. See Core::X86::Msr::HWCR[EffFreqCntMwait], 2.1.6 [Effective Frequency]"

#MSR0000_00E8 [Actual Performance Frequency Clock Count] (Core::X86::Msr::APERF)
##Read-write,Volatile. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_00E8"
	63:0	APERF: actual core clocks counter. Read-write,Volatile. Reset: 0000_0000_0000_0000h. This register increments in proportion to the actual number of core clocks cycles while the core is in C0. The register does not increment when the core is in the stop-grant state. See Core::X86::Msr::MPERF.

#MSR0000_00FE [MTRR Capabilities] (Core::X86::Msr::MTRRcap)
##Read,Error-on-write. Reset: 0000_0000_0000_0508h.
###"_ccd[7:0]_lthree0_core[7:0]; MSR0000_00FE"
	63:11	Reserved.
	10	"MtrrCapWc: write-combining memory type. Read,Error-on-write. Reset: 1. 1=The write combining memory type is supported."
	9	Reserved.
	8	MtrrCapFix: fixed range register. Read,Error-on-write. Reset: 1. 1=Fixed MTRRs are supported.
	7:0	"MtrrCapVCnt: variable range registers count. Read,Error-on-write. Reset: 08h. Specifies the number of variable MTRRs supported."

#MSR0000_0174 [SYSENTER CS] (Core::X86::Msr::SYSENTER_CS)
##Read-write. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_0174"
	63:16	Reserved.
	15:0	SysEnterCS: SYSENTER target CS. Read-write. Reset: 0000h. Holds the called procedure code segment.

#MSR0000_0175 [SYSENTER ESP] (Core::X86::Msr::SYSENTER_ESP)
##Read-write. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_0175"
	63:32	Reserved.
	31:0	SysEnterESP: SYSENTER target SP. Read-write. Reset: 0000_0000h. Holds the called procedure stack
pointer.

#MSR0000_0176 [SYSENTER EIP] (Core::X86::Msr::SYSENTER_EIP)
##Read-write. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_0176"
	63:32	Reserved.
	31:0	SysEnterEIP: SYSENTER target IP. Read-write. Reset: 0000_0000h. Holds the called procedure instruction pointer.

#MSR0000_0179 [Global Machine Check Capabilities] (Core::X86::Msr::MCG_CAP)
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_0179"
	63:9	Reserved.
	8	"McgCtlP: MCG_CTL register present. Read-only,Error-on-write. Reset: Fixed,1. 1=The machine check control registers (MCi_CTL) are present. See 3.1 [Machine Check Architecture]."
	7:0	Count. Read-only,Error-on-write,Volatile. Reset: XXh. Indicates the number of error reporting banks visible to the core. This value may differ from core to core.

#MSR0000_017A [Global Machine Check Status] (Core::X86::Msr::MCG_STAT)
##Read-write,Volatile. Reset: 0000_0000_0000_0000h. See 3.1 [Machine Check Architecture].
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_017A"
	63:3	Reserved.
	2	MCIP. Read-write,Volatile. Reset: 0. 1=A machine check is in progress. Machine check in progress.
	1	"EIPV: error instruction pointer valid. Read-write,Volatile. Reset: 0. 1=The instruction pointer that was pushed onto the stack by the machine check mechanism references the instruction that caused the machine check error."
	0	RIPV: restart instruction pointer valid. Read-write,Volatile. Reset: 0. 0=The interrupt was not precise and/or the process (task) context may be corrupt; continued operation of this process may not be possible without intervention, however system processing or other processes may be able to continue with appropriate software clean up. 1=Program execution can be reliably restarted at the EIP address on the stack.

#MSR0000_017B [Global Machine Check Exception Reporting Control] (Core::X86::Msr::MCG_CTL)
##Reset: 0000_0000_0000_0000h. "This register controls enablement of the individual error reporting banks; see 3.1 [Machine Check Architecture] and" "3.1.2.1 [Global Registers]. When a machine check register bank is not enabled in MCG_CTL, errors for that bank are not" logged or reported, and actions enabled through the MCA are not taken; each MCi_CTL register identifies which errors are still corrected when MCG_CTL[i] is disabled.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_017B"
	63:7	MCnEn. Configurable. Reset: 000_0000_0000_0000h.
Description: 1=The MC machine check register bank is enabled. Width of this field is SOC implementation and
configuration specific.
See 3.1.2.1 [Global Registers].
	6:0	MCnEnCore. Read-write. Reset: 00h. 1=The MC machine check register bank is enabled.
ValidValues:
"[0] Enable MCA for LSDC."
"[1] Enable MCA for ICBP."
"[2] Enable MCA for L2."
"[3] Enable MCA for DE."
"[4] Reserved."
"[5] Enable MCA for SCEX."
"[6] Enable MCA for FP."
ValidValuesEnd

#MSR0000_01D9 [Debug Control] (Core::X86::Msr::DBG_CTL_MSR)
##Read-write. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_01D9"
	63:6	Reserved.
	5:2	PB: performance monitor pin control. Read-write. Reset: 0h. This field does not control any hardware.
	1	BTF. Read-write. Reset: 0. 1=Enable branch single step.
	0	LBR. Read-write. Reset: 0. 1=Enable last branch record.

#MSR0000_01DB [Last Branch From IP] (Core::X86::Msr::BR_FROM)
##Read,Error-on-write,Volatile. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_01DB"
	63:0	LastBranchFromIP. Read,Error-on-write,Volatile. Reset: 0000_0000_0000_0000h. Loaded with the segment
offset of the branch instruction.

#MSR0000_01DC [Last Branch To IP] (Core::X86::Msr::BR_TO)
##Read,Error-on-write,Volatile. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_01DC"
	63:61	Reserved.
	60:0	LastBranchToIP. Read,Error-on-write,Volatile. Reset: 0000_0000_0000_0000h. Holds the target RIP of the last branch that occurred before an exception or interrupt.

#MSR0000_01DD [Last Exception From IP] (Core::X86::Msr::LastExcpFromIp)
##Read,Error-on-write,Volatile. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_01DD"
	63:0	LastIntFromIP. Read,Error-on-write,Volatile. Reset: 0000_0000_0000_0000h. Holds the source RIP of the last branch that occurred before the exception or interrupt.

#MSR0000_01DE [Last Exception To IP] (Core::X86::Msr::LastExcpToIp)
##Read,Error-on-write,Volatile. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_01DE"
	63:61	Reserved.
	60:0	LastIntToIP. Read,Error-on-write,Volatile. Reset: 0000_0000_0000_0000h. Holds the target RIP of the last branch that occurred before the exception or interrupt.

#MSR0000_020[0...E] [Variable-Size MTRRs Base] (Core::X86::Msr::MtrrVarBase)
##Each MTRR (Core::X86::Msr::MtrrVarBase, Core::X86::Msr::MtrrFix_64K through Core::X86::Msr::MtrrFix_4K_7, or Core::X86::Msr::MTRRdefType) specifies a physical address range and a corresponding memory type (MemType) associated with that range. Setting the memory type to an unsupported value results in a #GP. The variable-size MTRRs come in pairs of base and mask registers (MSR0000_0200 and MSR0000_0201 are the first pair, etc.). Variables MTRRs are enabled through Core::X86::Msr::MTRRdefType[MtrrDefTypeEn]. A core access--with address CPUAddr--is determined to be within the address range of a variable-size MTRR if the following equation is true: CPUAddr[47:12] & PhyMask[47:12] == PhyBase[47:12] & PhyMask[47:12]. For example, if the variable MTRR spans 256 KB and starts at the 1-MB address the PhyBase would be set to 0_0010_0000h and the PhyMask to F_FFFC_0000h (with zeros filling in for bits[11:0]). This results in a range from 0_0010_0000h to 0_0013_FFFFh.
###"_ccd[7:0]_lthree0_core[7:0]_n0; MSR0000_0200"
###"_ccd[7:0]_lthree0_core[7:0]_n1; MSR0000_0202"
###"_ccd[7:0]_lthree0_core[7:0]_n2; MSR0000_0204"
###"_ccd[7:0]_lthree0_core[7:0]_n3; MSR0000_0206"
###"_ccd[7:0]_lthree0_core[7:0]_n4; MSR0000_0208"
###"_ccd[7:0]_lthree0_core[7:0]_n5; MSR0000_020A"
###"_ccd[7:0]_lthree0_core[7:0]_n6; MSR0000_020C"
###"_ccd[7:0]_lthree0_core[7:0]_n7; MSR0000_020E"
	63:48	Reserved.
	47:12	PhyBase: base address. Read-write. Reset: X_XXXX_XXXXh. Physical base address.
	11:3	Reserved.
	2:0	MemType: memory type. Read-write. Reset: XXXb. Address range from 00000h to 0FFFFh.
ValidValues:
0h	UC or uncacheable.
1h	WC or write combining.
3h-2h	Reserved.
4h	WT or write through.
5h	WP or write protect.
6h	WB or write back.
7h	Reserved.
ValidValuesEnd

#MSR0000_020[1...F] [Variable-Size MTRRs Mask] (Core::X86::Msr::MtrrVarMask)
###"_ccd[7:0]_lthree0_core[7:0]_n0; MSR0000_0201"
###"_ccd[7:0]_lthree0_core[7:0]_n1; MSR0000_0203"
###"_ccd[7:0]_lthree0_core[7:0]_n2; MSR0000_0205"
###"_ccd[7:0]_lthree0_core[7:0]_n3; MSR0000_0207"
###"_ccd[7:0]_lthree0_core[7:0]_n4; MSR0000_0209"
###"_ccd[7:0]_lthree0_core[7:0]_n5; MSR0000_020B"
###"_ccd[7:0]_lthree0_core[7:0]_n6; MSR0000_020D"
###"_ccd[7:0]_lthree0_core[7:0]_n7; MSR0000_020F"
	63:48	Reserved.
	47:12	PhyMask: address mask. Read-write. Reset: X_XXXX_XXXXh. Physical address mask.
	11	Valid: valid. Read-write. Reset: X. 1=The variable-size MTRR pair is enabled.
	10:0	Reserved.

#MSR0000_0250 [Fixed-Size MTRRs] (Core::X86::Msr::MtrrFix_64K)
##See Core::X86::Msr::MtrrVarBase for general MTRR information. Fixed MTRRs are enabled through Core::X86::Msr::MTRRdefType[MtrrDefTypeFixEn,MtrrDefTypeEn]. For addresses below 1-MB, the appropriate Fixed MTRRs override the default access destination. Each fixed MTRR includes two bits, RdDram and WrDram, that determine the destination based on the access type. Writing Reserved MemType values causes an error-on-write.
###"_ccd[7:0]_lthree0_core[7:0]_nSIZE64K; MSR0000_0250"
	63:61	Reserved.
	60	RdDram_64K_70000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ?Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	59	WrDram_64K_70000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	58:56	MemType_64K_70000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	55:53	Reserved.
	52	RdDram_64K_60000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	51	WrDram_64K_60000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	50:48	MemType_64K_60000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	47:45	Reserved.
	44	RdDram_64K_50000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	43	WrDram_64K_50000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	42:40	MemType_64K_50000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	39:37	Reserved.
	36	RdDram_64K_40000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	35	WrDram_64K_40000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	34:32	MemType_64K_40000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	31:29	Reserved.
	28	RdDram_64K_30000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	27	WrDram_64K_30000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	26:24	MemType_64K_30000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	23:21	Reserved.
	20	RdDram_64K_20000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	19	WrDram_64K_20000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	18:16	MemType_64K_20000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	15:13	Reserved.
	12	RdDram_64K_10000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	11	WrDram_64K_10000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	10:8	MemType_64K_10000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	7:5	Reserved.
	4	RdDram_64K_00000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. Address range from 00000h to 0FFFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset:
Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	3	WrDram_64K_00000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. Address range from 00000h to 0FFFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	2:0	MemType_64K_00000: memory type. Read-write. Reset: XXXb. Address range from 00000h to 0FFFFh.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd

#MSR0000_0258 [Fixed-Size MTRRs] (Core::X86::Msr::MtrrFix_16K_0)
##See Core::X86::Msr::MtrrVarBase for general MTRR information. Fixed MTRRs are enabled through Core::X86::Msr::MTRRdefType[MtrrDefTypeFixEn,MtrrDefTypeEn]. For addresses below 1-MB, the appropriate Fixed MTRRs override the default access destination. Each fixed MTRR includes two bits, RdDram and WrDram, that determine the destination based on the access type. Writing Reserved MemType values causes an error-on-write.
###"_ccd[7:0]_lthree0_core[7:0]_nSIZE16K0; MSR0000_0258"
	63:61	Reserved.
	60	RdDram_16K_9C000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	59	WrDram_16K_9C000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	58:56	MemType_16K_9C000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	55:53	Reserved.
	52	RdDram_16K_98000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	51	WrDram_16K_98000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	50:48	MemType_16K_98000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	47:45	Reserved.
	44	RdDram_16K_94000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	43	WrDram_16K_94000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	42:40	MemType_16K_94000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	39:37	Reserved.
	36	RdDram_16K_90000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	35	WrDram_16K_90000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	34:32	MemType_16K_90000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	31:29	Reserved.
	28	RdDram_16K_8C000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	27	WrDram_16K_8C000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset:Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	26:24	MemType_16K_8C000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	23:21	Reserved.
	20	RdDram_16K_88000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	19	WrDram_16K_88000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	18:16	MemType_16K_88000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	15:13	Reserved.
	12	RdDram_16K_84000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	11	WrDram_16K_84000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	10:8	MemType_16K_84000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	7:5	Reserved.
	4	RdDram_16K_80000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. Address range from 80000h to 83FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	3	WrDram_16K_80000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. Address range from 80000h to 83FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	2:0	MemType_16K_80000: memory type. Read-write. Reset: XXXb. Address range from 80000h to 83FFFh.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd

#MSR0000_0259 [Fixed-Size MTRRs] (Core::X86::Msr::MtrrFix_16K_1)
##See Core::X86::Msr::MtrrVarBase for general MTRR information. Fixed MTRRs are enabled through Core::X86::Msr::MTRRdefType[MtrrDefTypeFixEn,MtrrDefTypeEn]. For addresses below 1 MB, the appropriate Fixed MTRRs override the default access destination. Each fixed MTRR includes two bits, RdDram and WrDram, that determine the destination based on the access type. Writing Reserved MemType values causes an error-on-write.
###"_ccd[7:0]_lthree0_core[7:0]_nSIZE16K1; MSR0000_0259"
	63:61	Reserved.
	60	RdDram_16K_BC000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	59	WrDram_16K_BC000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	58:56	MemType_16K_BC000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	55:53	Reserved.
	52	RdDram_16K_B8000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	51	WrDram_16K_B8000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	50:48	MemType_16K_B8000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	47:45	Reserved.
	44	RdDram_16K_B4000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	43	WrDram_16K_B4000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	42:40	MemType_16K_B4000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	39:37	Reserved.
	36	RdDram_16K_B0000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	35	WrDram_16K_B0000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	34:32	MemType_16K_B0000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	31:29	Reserved.
	28	RdDram_16K_AC000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	27	WrDram_16K_AC000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	26:24	MemType_16K_AC000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	23:21	Reserved.
	20	RdDram_16K_A8000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	19	WrDram_16K_A8000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	18:16	MemType_16K_A8000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	15:13	Reserved.
	12	RdDram_16K_A4000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	11	WrDram_16K_A4000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	10:8	MemType_16K_A4000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	7:5	Reserved.
	4	RdDram_16K_A0000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. Address range from A0000h to A3FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	3	WrDram_16K_A0000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. Address range from A0000h to A3FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	2:0	MemType_16K_A0000: memory type. Read-write. Reset: XXXb. Address range from A0000h to A3FFFh.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd

#MSR0000_0268 [Fixed-Size MTRRs] (Core::X86::Msr::MtrrFix_4K_0)
##See Core::X86::Msr::MtrrVarBase for general MTRR information. Fixed MTRRs are enabled through Core::X86::Msr::MTRRdefType[MtrrDefTypeFixEn,MtrrDefTypeEn]. For addresses below 1-MB, the appropriate Fixed MTRRs override the default access destination. Each fixed MTRR includes two bits, RdDram and WrDram, that determine the destination based on the access type. Writing Reserved MemType values causes an error-on-write.
###"_ccd[7:0]_lthree0_core[7:0]_nSIZE4K0; MSR0000_0268"
	63:61	Reserved.
	60	RdDram_4K_C7000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	59	WrDram_4K_C7000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	58:56	MemType_4K_C7000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	55:53	Reserved.
	52	RdDram_4K_C6000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	51	WrDram_4K_C6000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	50:48	MemType_4K_C6000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	47:45	Reserved.
	44	RdDram_4K_C5000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	43	WrDram_4K_C5000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	42:40	MemType_4K_C5000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	39:37	Reserved.
	36	RdDram_4K_C4000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	35	WrDram_4K_C4000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	34:32	MemType_4K_C4000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	31:29	Reserved.
	28	RdDram_4K_C3000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	27	WrDram_4K_C3000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	26:24	MemType_4K_C3000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	23:21	Reserved.
	20	RdDram_4K_C2000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	19	WrDram_4K_C2000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	18:16	MemType_4K_C2000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	15:13	Reserved.
	12	RdDram_4K_C1000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	11	WrDram_4K_C1000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	10:8	MemType_4K_C1000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	7:5	Reserved.
	4	RdDram_4K_C0000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. Address range from C0000h to C0FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	3	WrDram_4K_C0000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. Address range from C0000h to C0FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	2:0	MemType_4K_C0000: memory type. Read-write. Reset: XXXb. Address range from C0000h to C0FFFh.
ValidValues:
0h	UC or uncacheable.
1h	WC or write combining.
3h-2h	Reserved.
4h	WT or write through.
5h	WP or write protect.
6h	WB or write back.
7h	Reserved.
ValidValuesEnd

#MSR0000_0269 [Fixed-Size MTRRs] (Core::X86::Msr::MtrrFix_4K_1)
##See Core::X86::Msr::MtrrVarBase for general MTRR information. Fixed MTRRs are enabled through Core::X86::Msr::MTRRdefType[MtrrDefTypeFixEn,MtrrDefTypeEn]. For addresses below 1-MB, the appropriate Fixed MTRRs override the default access destination. Each fixed MTRR includes two bits, RdDram and WrDram, that determine the destination based on the access type. Writing Reserved MemType values causes an error-on-write.
###"_ccd[7:0]_lthree0_core[7:0]_nSIZE4K1; MSR0000_0269"
	63:61	Reserved.
	60	RdDram_4K_CF000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	59	WrDram_4K_CF000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	58:56	MemType_4K_CF000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	55:53	Reserved.
	52	RdDram_4K_CE000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	51	WrDram_4K_CE000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	50:48	MemType_4K_CE000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	47:45	Reserved.
	44	RdDram_4K_CD000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	43	WrDram_4K_CD000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	42:40	MemType_4K_CD000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	39:37	Reserved.
	36	RdDram_4K_CC000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	35	WrDram_4K_CC000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	34:32	MemType_4K_CC000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	31:29	Reserved.
	28	RdDram_4K_CB000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	27	WrDram_4K_CB000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	26:24	MemType_4K_CB000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	23:21	Reserved.
	20	RdDram_4K_CA000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	19	WrDram_4K_CA000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	18:16	MemType_4K_CA000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	15:13	Reserved.
	12	RdDram_4K_C9000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	11	WrDram_4K_C9000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	10:8	MemType_4K_C9000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	7:5	Reserved.
	4	RdDram_4K_C8000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. Address range from C8000 to C8FFF. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	3	WrDram_4K_C8000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. Address range from C8000 to C8FFF. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	2:0	MemType_4K_C8000: memory type. Read-write. Reset: XXXb. Address range from C8000 to C8FFF.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd

#MSR0000_026A [Fixed-Size MTRRs] (Core::X86::Msr::MtrrFix_4K_2)
##See Core::X86::Msr::MtrrVarBase for general MTRR information. Fixed MTRRs are enabled through Core::X86::Msr::MTRRdefType[MtrrDefTypeFixEn,MtrrDefTypeEn]. For addresses below 1-MB, the appropriate Fixed MTRRs override the default access destination. Each fixed MTRR includes two bits, RdDram and WrDram, that determine the destination based on the access type. Writing Reserved MemType values causes an error-on-write.
###"_ccd[7:0]_lthree0_core[7:0]_nSIZE4K2; MSR0000_026A"
	63:61	Reserved.
	60	RdDram_4K_D7000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	59	WrDram_4K_D7000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	58:56	MemType_4K_D7000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	55:53	Reserved.
	52	RdDram_4K_D6000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	51	WrDram_4K_D6000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	50:48	MemType_4K_D6000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	47:45	Reserved.
	44	RdDram_4K_D5000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	43	WrDram_4K_D5000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	42:40	MemType_4K_D5000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	39:37	Reserved.
	36	RdDram_4K_D4000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	35	WrDram_4K_D4000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	34:32	MemType_4K_D4000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	31:29	Reserved.
	28	RdDram_4K_D3000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	27	WrDram_4K_D3000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	26:24	MemType_4K_D3000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	23:21	Reserved.
	20	RdDram_4K_D2000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	19	WrDram_4K_D2000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	18:16	MemType_4K_D2000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	15:13	Reserved.
	12	RdDram_4K_D1000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	11	WrDram_4K_D1000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	10:8	MemType_4K_D1000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	7:5	Reserved.
	4	RdDram_4K_D0000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. Address range from D0000h to D0FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	3	WrDram_4K_D0000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. Address range from D0000h to D0FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	2:0	MemType_4K_D0000: memory type. Read-write. Reset: XXXb. Address range from D0000h to D0FFFh.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd

#MSR0000_026B [Fixed-Size MTRRs] (Core::X86::Msr::MtrrFix_4K_3)
##See Core::X86::Msr::MtrrVarBase for general MTRR information. Fixed MTRRs are enabled through Core::X86::Msr::MTRRdefType[MtrrDefTypeFixEn,MtrrDefTypeEn]. For addresses below 1-MB, the appropriate Fixed MTRRs override the default access destination. Each fixed MTRR includes two bits, RdDram and WrDram, that determine the destination based on the access type. Writing Reserved MemType values causes an error-on-write.
###"_ccd[7:0]_lthree0_core[7:0]_nSIZE4K3; MSR0000_026B"
	63:61	Reserved.
	60	RdDram_4K_DF000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	59	WrDram_4K_DF000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	58:56	MemType_4K_DF000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	55:53	Reserved.
	52	RdDram_4K_DE000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	51	WrDram_4K_DE000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	50:48	MemType_4K_DE000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	47:45	Reserved.
	44	RdDram_4K_DD000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	43	WrDram_4K_DD000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	42:40	MemType_4K_DD000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	39:37	Reserved.
	36	RdDram_4K_DC000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	35	WrDram_4K_DC000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	34:32	MemType_4K_DC000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	31:29	Reserved.
	28	RdDram_4K_DB000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	27	WrDram_4K_DB000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	26:24	MemType_4K_DB000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	23:21	Reserved.
	20	RdDram_4K_DA000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	19	WrDram_4K_DA000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	18:16	MemType_4K_DA000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	15:13	Reserved.
	12	RdDram_4K_D9000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	11	WrDram_4K_D9000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	10:8	MemType_4K_D9000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	7:5	Reserved.
	4	RdDram_4K_D8000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. Address range from D8000h to D8FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	3	WrDram_4K_D8000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. Address range from D8000h to D8FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	2:0	MemType_4K_D8000: memory type. Read-write. Reset: XXXb. Address range from D8000h to D8FFFh.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h	Reserved.
ValidValuesEnd

#MSR0000_026C [Fixed-Size MTRRs] (Core::X86::Msr::MtrrFix_4K_4)
##See Core::X86::Msr::MtrrVarBase for general MTRR information. Fixed MTRRs are enabled through Core::X86::Msr::MTRRdefType[MtrrDefTypeFixEn,MtrrDefTypeEn]. For addresses below 1-MB, the appropriate Fixed MTRRs override the default access destination. Each fixed MTRR includes two bits, RdDram and WrDram, that determine the destination based on the access type. Writing Reserved MemType values causes an error-on-write.
###"_ccd[7:0]_lthree0_core[7:0]_nSIZE4K4; MSR0000_026C"
	63:61	Reserved.
	60	RdDram_4K_E7000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	59	WrDram_4K_E7000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	58:56	MemType_4K_E7000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	55:53	Reserved.
	52	RdDram_4K_E6000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	51	WrDram_4K_E6000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	50:48	MemType_4K_E6000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	47:45	Reserved.
	44	RdDram_4K_E5000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	43	WrDram_4K_E5000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	42:40	MemType_4K_E5000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	39:37	Reserved.
	36	RdDram_4K_E4000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	35	WrDram_4K_E4000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	34:32	MemType_4K_E4000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	31:29	Reserved.
	28	RdDram_4K_E3000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	27	WrDram_4K_E3000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	26:24	MemType_4K_E3000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	23:21	Reserved.
	20	RdDram_4K_E2000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	19	WrDram_4K_E2000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	18:16	MemType_4K_E2000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	15:13	Reserved.
	12	RdDram_4K_E1000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	11	WrDram_4K_E1000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	10:8	MemType_4K_E1000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	7:5	Reserved.
	4	RdDram_4K_E0000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. Address range from E0000h to E0FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	3	WrDram_4K_E0000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. Address range from E0000h to E0FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	2:0	MemType_4K_E0000: memory type. Read-write. Reset: XXXb. Address range from E0000h to E0FFFh.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd

#MSR0000_026D [Fixed-Size MTRRs] (Core::X86::Msr::MtrrFix_4K_5)
##See Core::X86::Msr::MtrrVarBase for general MTRR information. Fixed MTRRs are enabled through Core::X86::Msr::MTRRdefType[MtrrDefTypeFixEn,MtrrDefTypeEn]. For addresses below 1-MB, the appropriate Fixed MTRRs override the default access destination. Each fixed MTRR includes two bits, RdDram and WrDram, that determine the destination based on the access type. Writing Reserved MemType values causes an error-on-write.
###"_ccd[7:0]_lthree0_core[7:0]_nSIZE4K5; MSR0000_026D"
	63:61	Reserved.
	60	RdDram_4K_EF000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	59	WrDram_4K_EF000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	58:56	MemType_4K_EF000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	55:53	Reserved.
	52	RdDram_4K_EE000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	51	WrDram_4K_EE000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	50:48	MemType_4K_EE000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	47:45	Reserved.
	44	RdDram_4K_ED000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	43	WrDram_4K_ED000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	42:40	MemType_4K_ED000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	39:37	Reserved.
	36	RdDram_4K_EC000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	35	WrDram_4K_EC000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	34:32	MemType_4K_EC000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	31:29	Reserved.
	28	RdDram_4K_EB000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	27	WrDram_4K_EB000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	26:24	MemType_4K_EB000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	23:21	Reserved.
	20	RdDram_4K_EA000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	19	WrDram_4K_EA000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	18:16	MemType_4K_EA000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	15:13	Reserved.
	12	RdDram_4K_E9000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	11	WrDram_4K_E9000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	10:8	MemType_4K_E9000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	7:5	Reserved.
	4	RdDram_4K_E8000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. Address range from E8000h to E8FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	3	WrDram_4K_E8000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. Address range from E8000h to E8FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	2:0	MemType_4K_E8000: memory type. Read-write. Reset: XXXb. Address range from E8000h to E8FFFh.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd

#MSR0000_026E [Fixed-Size MTRRs] (Core::X86::Msr::MtrrFix_4K_6)
##See Core::X86::Msr::MtrrVarBase for general MTRR information. Fixed MTRRs are enabled through Core::X86::Msr::MTRRdefType[MtrrDefTypeFixEn,MtrrDefTypeEn]. For addresses below 1-MB, the appropriate Fixed MTRRs override the default access destination. Each fixed MTRR includes two bits, RdDram and WrDram, that determine the destination based on the access type. Writing Reserved MemType values causes an error-on-write.
###"_ccd[7:0]_lthree0_core[7:0]_nSIZE4K6; MSR0000_026E"
	63:61	Reserved.
	60	RdDram_4K_F7000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	59	WrDram_4K_F7000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	58:56	MemType_4K_F7000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	55:53	Reserved.
	52	RdDram_4K_F6000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	51	WrDram_4K_F6000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	50:48	MemType_4K_F6000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	47:45	Reserved.
	44	RdDram_4K_F5000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	43	WrDram_4K_F5000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	42:40	MemType_4K_F5000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	39:37	Reserved.
	36	RdDram_4K_F4000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	35	WrDram_4K_F4000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	34:32	MemType_4K_F4000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	31:29	Reserved.
	28	RdDram_4K_F3000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	27	WrDram_4K_F3000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	26:24	MemType_4K_F3000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	23:21	Reserved.
	20	RdDram_4K_F2000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	19	WrDram_4K_F2000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	18:16	MemType_4K_F2000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	15:13	Reserved.
	12	RdDram_4K_F1000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	11	WrDram_4K_F1000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	10:8	MemType_4K_F1000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	7:5	Reserved.
	4	RdDram_4K_F0000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. Address range from F0000h to F0FFF. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	3	WrDram_4K_F0000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. Address range from F0000h to F0FFF. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	2:0	MemType_4K_F0000: memory type. Read-write. Reset: XXXb. Address range from F0000h to F0FFFh.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd

#MSR0000_026F [Fixed-Size MTRRs] (Core::X86::Msr::MtrrFix_4K_7)
##See Core::X86::Msr::MtrrVarBase for general MTRR information. Fixed MTRRs are enabled through Core::X86::Msr::MTRRdefType[MtrrDefTypeFixEn,MtrrDefTypeEn]. For addresses below 1-MB, the appropriate Fixed MTRRs override the default access destination. Each fixed MTRR includes two bits, RdDram and WrDram, that determine the destination based on the access type. Writing Reserved MemType values causes an error-on-write.
###"_ccd[7:0]_lthree0_core[7:0]_nSIZE4K7; MSR0000_026F"
	63:61	Reserved.
	60	RdDram_4K_FF000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	59	WrDram_4K_FF000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	58:56	MemType_4K_FF000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	55:53	Reserved.
	52	RdDram_4K_FE000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	51	WrDram_4K_FE000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	50:48	MemType_4K_FE000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	47:45	Reserved.
	44	RdDram_4K_FD000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	43	WrDram_4K_FD000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	42:40	MemType_4K_FD000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	39:37	Reserved.
	36	RdDram_4K_FC000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	35	WrDram_4K_FC000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	34:32	MemType_4K_FC000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	31:29	Reserved.
	28	RdDram_4K_FB000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	27	WrDram_4K_FB000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	26:24	MemType_4K_FB000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	23:21	Reserved.
	20	RdDram_4K_FA000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	19	WrDram_4K_FA000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	18:16	MemType_4K_FA000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	15:13	Reserved.
	12	RdDram_4K_F9000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	11	WrDram_4K_F9000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	10:8	MemType_4K_F9000: memory type. Read-write. Reset: XXXb.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	7:5	Reserved.
	4	RdDram_4K_F8000: read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. Address range from F8000h to F8FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	3	WrDram_4K_F8000: write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. Address range from F8000h to F8FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0.
	2:0	MemType_4K_F8000: memory type. Read-write. Reset: XXXb. Address range from F8000h to F8FFFh.
ValidValues:
0h	UC or uncacheable.
1h	WC or write combining.
3h-2h	Reserved.
4h	WT or write through.
5h	WP or write protect.
6h	WB or write back.
7h	Reserved.
ValidValuesEnd

#MSR0000_0277 [Page Attribute Table] (Core::X86::Msr::PAT)
##This register specifies the memory type based on the PAT, PCD, and PWT bits in the virtual address page tables.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_0277"
	63:59	Reserved.
	58:56	PA7MemType. Read-write. Reset: 0h. Default UC. MemType for {PAT, PCD, PWT} = 7h.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	55:51	Reserved.
	50:48	PA6MemType. Read-write. Reset: 7h. Default UC. MemType for {PAT, PCD, PWT} = 6h.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	47:43	Reserved.
	42:40	PA5MemType. Read-write. Reset: 4h. Default WT. MemType for {PAT, PCD, PWT} = 5h.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	39:35	Reserved.
	34:32	PA4MemType. Read-write. Reset: 6h. Default WB. MemType for {PAT, PCD, PWT} = 4h.
ValidValues:
0h	UC or uncacheable.
1h	WC or write combining.
3h-2h	Reserved.
4h	WT or write through.
5h	WP or write protect.
6h	WB or write back.
7h	Reserved.
ValidValuesEnd
	31:27	Reserved.
	26:24	PA3MemType. Read-write. Reset: 0h. Default UC. MemType for {PAT, PCD, PWT} = 3h.
ValidValues:
0h	UC or uncacheable.
1h	WC or write combining.
3h-2h	Reserved.
4h	WT or write through.
5h	WP or write protect.
6h	WB or write back.
7h	Reserved.
ValidValuesEnd
	23:19	Reserved.
	18:16	PA2MemType. Read-write. Reset: 7h. Default UC. MemType for {PAT, PCD, PWT} = 2h.
ValidValues:
0h	UC or uncacheable.
1h	WC or write combining.
3h-2h	Reserved.
4h	WT or write through.
5h	WP or write protect.
6h	WB or write back.
7h	Reserved.
ValidValuesEnd
	15:11	Reserved.
	10:8	PA1MemType. Read-write. Reset: 4h. Default WT. MemType for {PAT, PCD, PWT} = 1h.
ValidValues:
0h	UC or uncacheable.
1h	WC or write combining.
3h-2h	Reserved.
4h	WT or write through.
5h	WP or write protect.
6h	WB or write back.
7h	Reserved.
ValidValuesEnd
	7:3	Reserved.
	2:0	PA0MemType. Read-write. Reset: 6h. MemType for {PAT, PCD, PWT} = 0h.
ValidValues:
0h	UC or uncacheable.
1h	WC or write combining.
4h	WT or write through.
5h	WP or write protect.
6h	WB or write back.
7h	Reserved.
ValidValuesEnd

#MSR0000_02FF [MTRR Default Memory Type] (Core::X86::Msr::MTRRdefType)
##See Core::X86::Msr::MtrrVarBase for general MTRR information.
###"_ccd[7:0]_lthree0_core[7:0]; MSR0000_02FF"
	63:12	Reserved.
	11	MtrrDefTypeEn: variable and fixed MTRR enable. Read-write. Reset: 0. 0=Fixed and variable MTRRs are not enabled. 1=Core::X86::Msr::MtrrVarBase, and Core::X86::Msr::MtrrFix_64K through Core::X86::Msr::MtrrFix_4K_7 are enabled.
	10	MtrrDefTypeFixEn: fixed MTRR enable. Read-write. Reset: 0. 0=Core::X86::Msr::MtrrFix_64K through Core::X86::Msr::MtrrFix_4K_7 are not enabled. 1=Core::X86::Msr::MtrrFix_64K through Core::X86::Msr::MtrrFix_4K_7 are enabled. This field is ignored (and the fixed MTRRs are not enabled) if Core::X86::Msr::MTRRdefType[MtrrDefTypeEn] == 0.
	9:8	Reserved.
	7:0	MemType: memory type. Read-write. Reset: 00h. Description: If MtrrDefTypeEn == 1, then MemType specifies the memory type for memory space that is not specified by either the fixed or variable range MTRRs. If MtrrDefTypeEn == 0, then the default memory type for all of memory is UC. Valid encodings are {00000b, Core::X86::Msr::MtrrFix_64K through Core::X86::Msr::MtrrFix_4K_7[2:0]}. Other write values cause a GP(0).

#MSR0000_06A0 [User CET] (Core::X86::Msr::U_CET)
##Read-write. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_06A0"
	63:2	Reserved.
	1	WRSHSTKEN. Read-write. Reset: 0. Enables the WRSS instruction in User Mode.
	0	SHSTKEN. Read-write. Reset: 0. When Set Shadow stack is enabled in User mode.

#MSR0000_06A2 [Supervisor CET] (Core::X86::Msr::S_CET)
##Read-write. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_06A2"
	63:2	Reserved.
	1	WRSHSTKEN. Read-write. Reset: 0. Enables the WRSS instruction in Supervisor Mode.
	0	SHSTKEN. Read-write. Reset: 0. When Set Shadow stack is enabled in Supervisor mode.

#MSR0000_06A4 [PL0 Shadow Stack Pointer] (Core::X86::Msr::PL0Ssp)
##Read-write. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_06A4"
	63:2	UserLinAddress: PL0 user top of SSP. Read-write. Reset: 0000_0000_0000_0000h. UserLinAddress[63:32] must be zero in 32-bit mode.
	1:0	Reserved.

#MSR0000_06A5 [PL1 Shadow Stack Pointer] (Core::X86::Msr::PL1Ssp)
##Read-write. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_06A5"
	63:2	"UserLinAddress: PL1 user top of SSP. Read-write. Reset: 0000_0000_0000_0000h. UserLinAddress[63:32] must be zero in 32-bit mode."
	1:0	Reserved.

#MSR0000_06A6 [PL2 Shadow Stack Pointer] (Core::X86::Msr::PL2Ssp)
##Read-write. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_06A6"
	63:2	"UserLinAddress: PL2 user top of SSP. Read-write. Reset: 0000_0000_0000_0000h. UserLinAddress[63:32] must be zero in 32-bit mode."
	1:0	Reserved.

#MSR0000_06A7 [PL3 Shadow Stack Pointer] (Core::X86::Msr::PL3Ssp)
##Read-write. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_06A7"
	63:2	"UserLinAddress: PL3 user top of SSP. Read-write. Reset: 0000_0000_0000_0000h. UserLinAddress[63:32] must be zero in 32-bit mode."
	1:0	Reserved.

#MSR0000_06A8 [Interrupt SSP Table Address] (Core::X86::Msr::IstSspAddr)
##Read-write. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_06A8"
	63:0	IntrLinTableAddress. Read-write. Reset: 0000_0000_0000_0000h. Shadow Stack Pointer interrupt table.

#MSR0000_0802 [APIC ID] (Core::X86::Msr::APIC_ID)
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_0802"
	63:32	Reserved.
	31:0	ApicId[31:0]: APIC ID[31:0]. Reset: XXXX_XXXXh. Local x2APIC ID register.

#MSR0000_0803 [APIC Version] (Core::X86::Msr::ApicVersion)
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_0803"
	63:32	Reserved.
	31	"ExtApicSpace: extended APIC register space present. Reset: 1. 1=Indicates the presence of extended APIC register space starting at Core::X86::Msr::ExtendedApicFeature." AccessType: X2APICEN ? Read-only,Error-on-write : Error-on-read,Error-on-write.
	30:25	Reserved.
	24	"DirectedEoiSupport: directed EOI support. Reset: 0. 0=Directed EOI capability not supported. 1=Directed EOI capability supported."
	23:16	MaxLvtEntry. Reset: XXh. Specifies the number of entries in the local vector table minus one. AccessType: X2APICEN ? Read-only,Error-on-write : Error-on-read,Error-on-write.
	15:8	Reserved.
	7:0	Version. Reset: 10h. Indicates the version number of this APIC implementation. AccessType: X2APICEN ? Read-only,Error-on-write : Error-on-read,Error-on-write.

#MSR0000_0808 [Task Priority] (Core::X86::Msr::TPR)
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_0808"
	63:8	Reserved.
	7:0	Priority. Reset: 00h. This field is assigned by software to set a threshold priority at which the core is interrupted.

#MSR0000_0809 [Arbitration Priority] (Core::X86::Msr::ArbitrationPriority)
##Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_0809"
	63:8	Reserved.
	7:0	"Priority. Reset: 00h. Indicates the current priority for a pending interrupt, or a task or interrupt being serviced by the core. The priority is used to arbitrate between cores to determine which accepts a lowest-priority interrupt request."

#MSR0000_080A [Processor Priority] (Core::X86::Msr::ProcessorPriority)
##Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_080A"
	63:8	Reserved.
	7:0	"Priority. Reset: 00h. Indicates the core's current priority servicing a task or interrupt, and is used to determine if any pending interrupts should be serviced. It is the higher value of the task priority value and the current highest in-service interrupt."

#MSR0000_080B [End Of Interrupt] (Core::X86::Msr::EOI)
##Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_080B"
	63:0	"EOI. Reset: 0000_0000_0000_0000h. A write zero to this field indicates the end of interrupt processing the currently in service interrupt." AccessType: X2APICEN ? Write-0-only,Error-on-read,Error-on-write-1 : Error-on-read,Error-on-write.

#MSR0000_080D [Logical Destination Register] (Core::X86::Msr::LDR)
##Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_080D"
	63:32	Reserved.
	31:16	ClusterDestination. Reset: 0000h. Specifies cluster's destination identification. AccessType: X2APICEN ? Read-only,Error-on-write : Error-on-read,Error-on-write.
	15:0	"LogicalDestination. Reset: 0000h. Specifies one of up to sixteen x2APICs within the cluster specified by ClusterDestination." AccessType: X2APICEN ? Read-only,Error-on-write : Error-on-read,Error-on-write.
ValidValues:
"[0]"	x2APIC[0]
"[1]"	x2APIC[1]
"[2]"	x2APIC[2]
"[3]"	x2APIC[3]
"[4]"	x2APIC[4]
"[5]"	x2APIC[5]
"[6]"	x2APIC[6]
"[7]"	x2APIC[7]
"[8]"	x2APIC[8]
"[9]"	x2APIC[9]
"[10]"	x2APIC[10]
"[11]"	x2APIC[11]
"[12]"	x2APIC[12]
"[13]"	x2APIC[13]
"[14]"	x2APIC[14]
"[15]"	x2APIC[15]
ValidValuesEnd

#MSR0000_080F [Spurious Interrupt Vector] (Core::X86::Msr::SVR)
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_080F"
	63:10	Reserved.
	9	FocusDisable. Reset: 0. 1=Disable focus core checking during lowest-priority arbitrated interrupts. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.
	8	APICSWEn: APIC software enable. Reset: 0. All LVT entry mask bits are set and cannot be cleared. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.
	7:0	Vector. Reset: FFh. The vector that is sent to the core in the event of a spurious interrupt. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.

#MSR0000_081[0...7] [In Service Register] (Core::X86::Msr::ISR)
##Reset: 0000_0000_0000_0000h. Interrupt In Service status bits[255:0] accessible through 8 ISR registers.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_nISR0_aliasMSR; MSR0000_0810"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_nISR1_aliasMSR; MSR0000_0811"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_nISR2_aliasMSR; MSR0000_0812"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_nISR3_aliasMSR; MSR0000_0813"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_nISR4_aliasMSR; MSR0000_0814"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_nISR5_aliasMSR; MSR0000_0815"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_nISR6_aliasMSR; MSR0000_0816"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_nISR7_aliasMSR; MSR0000_0817"
	63:32	Reserved.
	31:0	InServiceBits. Reset: 0000_0000h. These bits are set when the corresponding interrupt is being serviced by the core. AccessType: X2APICEN ? Read-only,Error-on-write,Volatile : Error-on-read,Error-on-write.

#MSR0000_081[8...F] [Trigger Mode Register] (Core::X86::Msr::TMR)
##Reset: 0000_0000_0000_0000h. Trigger Mode status bits[255:0] accessible through 8 TMR registers.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_nTMR0_aliasMSR; MSR0000_0818"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_nTMR1_aliasMSR; MSR0000_0819"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_nTMR2_aliasMSR; MSR0000_081A"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_nTMR3_aliasMSR; MSR0000_081B"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_nTMR4_aliasMSR; MSR0000_081C"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_nTMR5_aliasMSR; MSR0000_081D"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_nTMR6_aliasMSR; MSR0000_081E"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_nTMR7_aliasMSR; MSR0000_081F"
	63:32	Reserved.
	31:0	"TriggerModeBits. Reset: 0000_0000h. The corresponding trigger mode bit is updated when an interrupt is accepted." AccessType: X2APICEN ? Read-only,Error-on-write,Volatile : Error-on-read,Error-on-write.
ValidValues:
"[0]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[1]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[2]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[3]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[4]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[5]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[6]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[7]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[8]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[9]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[10]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[11]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[12]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[13]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[14]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[15]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[16]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[17]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[18]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[19]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[20]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[21]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[22]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[23]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[24]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[25]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[26]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[27]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[28]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[29]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[30]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
"[31]"	0=Edge-triggered interrupt. 1=Level-triggered interrupt.
ValidValuesEnd

#MSR0000_082[0...7] [Interrupt Request Register] (Core::X86::Msr::IRR)
##Reset: 0000_0000_0000_0000h. Interrupt Request status bits[255:0] accessible through 8 IRR registers.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_nIRR0_aliasMSR; MSR0000_0820"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_nIRR1_aliasMSR; MSR0000_0821"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_nIRR2_aliasMSR; MSR0000_0822"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_nIRR4_aliasMSR; MSR0000_0824"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_nIRR5_aliasMSR; MSR0000_0825"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_nIRR6_aliasMSR; MSR0000_0826"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_nIRR7_aliasMSR; MSR0000_0827"
	63:32	Reserved.
	31:0	"RequestBits. Reset: 0000_0000h. The corresponding request bit is set when the an interrupt is accepted by the x2APIC." AccessType: X2APICEN ? Read-only,Error-on-write,Volatile : Error-on-read,Error-on-write.

#MSR0000_0828 [Error Status Register] (Core::X86::Msr::ESR)
##Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_0828"
	63:8	Reserved.
	7	"IllegalRegAddr: illegal register address. Reset: 0. This bit indicates that an access to a nonexistent register location within this APIC was attempted. Can only be set in xAPIC mode." AccessType: X2APICEN ? Read,Write-0-only,Error-on-write-1,Volatile : Error-on-read,Error-on-write.
	6	"RcvdIllegalVector: received illegal vector. Reset: 0. This bit indicates that this APIC has received a message with an illegal vector (00h to 0Fh for fixed and lowest priority interrupts)." AccessType: X2APICEN ? Read,Write-0-only,Error-on-write-1,Volatile : Error-on-read,Error-on-write.
	5	"SentIllegalVector. Reset: 0. This bit indicates that this x2APIC attempted to send a message with an illegal vector (00h to 0Fh for fixed and lowest priority interrupts)." AccessType: X2APICEN ? Read,Write-0-only,Error-on-write-1,Volatile : Error-on-read,Error-on-write.
	4	Reserved.
	3	"RcvAcceptError: receive accept error. Reset: 0. This bit indicates that a message received by this APIC was not accepted by this or any other x2APIC." AccessType: X2APICEN ? Read,Write-0-only,Error-on-write-1,Volatile : Error-on-read,Error-on-write.
	2	"SendAcceptError. Reset: 0. This bit indicates that a message sent by this APIC was not accepted by any x2APIC." AccessType: X2APICEN ? Read,Write-0-only,Error-on-write-1,Volatile : Error-on-read,Error-on-write.
	1:0	Reserved.

#MSR0000_0830 [Interrupt Command] (Core::X86::Msr::InterruptCommand)
##Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_0830"
	63:32	"DestinationField. Reset: 0000_0000h. The destination encoding used when Core::X86::Msr::InterruptCommand[DestShrthnd] is 00b." AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.
	31:20	Reserved.
	19:18	"DestShrthnd: destination shorthand. Reset: 0h. Provides a quick way to specify a destination for a message. If all including self or all excluding self is used, then destination mode is ignored and physical is automatically used." AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.
ValidValues:
0h	No shorthand (Destination field).
1h	Self.
2h	All including self.
3h All excluding self. (This sends a message with a destination encoding of all 1s, so if lowest priority is used the message could end up being reflected back to this APIC.)
ValidValuesEnd
	17:16	Reserved.
	15	TM: trigger mode. Reset: 0. 0=Edge triggered. 1=Level triggered. Indicates how this interrupt is triggered. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.
	14	Level. Reset: 0. 0=Deasserted. 1=Asserted. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.
	13:12	Reserved.
	11	DM: destination mode. Reset: 0. 0=Physical. 1=Logical. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.
	10:8	MsgType. Reset: 0h. The message types are encoded as follows: AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.
ValidValues:
0h Fixed
1h Lowest Priority.
2h SMI
3h Reserved.
4h NMI
5h INIT
6h Startup
7h External interrupt.
ValidValuesEnd
	7:0	Vector. Reset: 00h. The vector that is sent for this interrupt source. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.

#MSR0000_0832 [LVT Timer] (Core::X86::Msr::TimerLvtEntry)
##Reset: 0000_0000_0001_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_0832"
	63:18	Reserved.
	17	Mode. Reset: 0. 0=One-shot. 1=Periodic. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.
	16	Mask. Reset: 1. 0=Not masked. 1=Masked. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.
	15:13	Reserved.
	12	DS: interrupt delivery status. Reset: 0. 0=Idle. 1=Send pending. (Indicates that the interrupt has not yet been accepted by the core.) AccessType: X2APICEN ? Read-only,Volatile : Error-on-read,Error-on-write.
	11:8	Reserved.
	7:0	Vector. Reset: 00h. Interrupt vector number. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.

#MSR0000_0833 [LVT Thermal Sensor] (Core::X86::Msr::ThermalLvtEntry)
##Reset: 0000_0000_0001_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_0833"
	63:17	Reserved.
	16	Mask. Reset: 1. 0=Not masked. 1=Masked. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.
	15:13	Reserved.
	12	DS: interrupt delivery status. Reset: 0. 0=Idle. 1=Send pending. (Indicates that the interrupt has not yet been accepted by the core.)
AccessType: X2APICEN ? Read-only,Volatile : Error-on-read,Error-on-write.
	11	Reserved.
	10:8	MsgType: message type. Reset: 0h. See2.1.14.2.1.14 [Generalized Local Vector Table]. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.
	7:0	Vector. Reset: 00h. Interrupt vector number. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.

#MSR0000_0834 [LVT Performance Monitor] (Core::X86::Msr::PerformanceCounterLvtEntry)
##Reset: 0000_0000_0001_0000h. "Interrupts for this local vector table are caused by overflows of: •Core::X86::Msr::PERF_LEGACY_CTL0..3 (Performance Event Select [3:0]). •Core::X86::Msr::PERF_CTL0..5 (Performance Event Select [5:0])."
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_0834"
	63:17	Reserved.
	16	Mask. Reset: 1. 0=Not masked. 1=Masked. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.
	15:13	Reserved.
	12	"DS: interrupt delivery status. Reset: 0. 0=Idle. 1=Send pending. Indicates that the interrupt has not yet been accepted by the core." AccessType: X2APICEN ? Read-only,Volatile : Error-on-read,Error-on-write.
	11	Reserved.
	10:8	MsgType: message type. Reset: 0h. See2.1.14.2.1.14 [Generalized Local Vector Table]. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.
	7:0	Vector. Reset: 00h. Interrupt vector number. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.

#MSR0000_083[5...6] [LVT LINT[1:0]] (Core::X86::Msr::LVTLINT)
##Reset: 0000_0000_0001_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_nLVTLINT0_aliasMSR; MSR0000_0835"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_nLVTLINT1_aliasMSR; MSR0000_0836"
	63:17	Reserved.
	16	Mask. Reset: 1. 0=Not masked. 1=Masked. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.
	15	TM: trigger mode. Reset: 0. 0=Edge. 1=Level. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.
	14	"RmtIRR. Reset: 0. If trigger mode is level, remote Core::X86::Msr::IRR is set when the interrupt has begun service. Remote Core::X86::Msr::IRR is cleared when the end of interrupt has occurred." AccessType: X2APICEN ? Read-only,Volatile : Error-on-read,Error-on-write.
	13	Reserved.
	12	"DS: interrupt delivery status. Reset: 0. 0=Idle. 1=Send pending. (Indicates that the interrupt has not yet been accepted by the core.)" AccessType: X2APICEN ? Read-only,Volatile : Error-on-read,Error-on-write.
	11	Reserved.
	10:8	MsgType: message type. Reset: 0h. See2.1.14.2.1.14 [Generalized Local Vector Table]. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.
	7:0	Vector. Reset: 00h. Interrupt vector number.

#MSR0000_0837 [LVT Error] (Core::X86::Msr::ErrorLvtEntry)
##Reset: 0000_0000_0001_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_0837"
	63:17	Reserved.
	16	Mask. Reset: 1. 0=Not masked. 1=Masked. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.
	15:13	Reserved.
	12	"DS: interrupt delivery status. Reset: 0. 0=Idle. 1=Send pending. (Indicates that the interrupt has not yet been accepted by the core.)" AccessType: X2APICEN ? Read-only,Volatile : Error-on-read,Error-on-write.
	11	Reserved.
	10:8	MsgType: message type. Reset: 0h. See 2.1.14.2.1.14 [Generalized Local Vector Table]. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.
	7:0	Vector. Reset: 00h. Interrupt vector number. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.

#MSR0000_0838 [Timer Initial Count] (Core::X86::Msr::TimerInitialCount)
##Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_0838"
	63:32	Reserved.
	31:0	Count. Reset: 0000_0000h. The value copied into the current count register when the timer is loaded or reloaded. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.

#MSR0000_0839 [Timer Current Count] (Core::X86::Msr::TimerCurrentCount)
##Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_0839"
	63:32	Reserved.
	31:0	Count. Reset: 0000_0000h. The current value of the counter. AccessType: X2APICEN ? Read,Error-on-write,Volatile : Error-on-read,Error-on-write.

#MSR0000_083E [Timer Divide Configuration] (Core::X86::Msr::TimerDivideConfiguration)
##Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_083E"
	63:4	Reserved.
	3:0	Div[3:0]. Reset: 0h. Div[2] is unused. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.
ValidValues:
0h	Divide by 2.
1h	Divide by 4.
2h	Divide by 8.
3h	Divide by 16.
7h-4h	Reserved.
8h	Divide by 32.
9h	Divide by 64.
Ah	Divide by 128.
Bh	Divide by 1.
Fh-Ch	Reserved.
ValidValuesEnd

#MSR0000_083F [Self IPI] (Core::X86::Msr::SelfIPI)
##Reset: 0000_0000_0000_0000h. The self IPI register provides a perforamnce optimized path for sending self IPI's. A self IPI is semantically identical to an inter-processor interrupt sent via the ICR, with a Destination Shorthand of Self, Trigger Mode equal to Edge, and a Delivery Mode equal to Fixed.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_083F"
	63:8	Reserved.
	7:0	Vector. Reset: 00h. Interrupt vector number. AccessType: X2APICEN ? Write-only,Error-on-read : Error-on-read,Error-on-write.

#MSR0000_0840 [Extended APIC Feature] (Core::X86::Msr::ExtendedApicFeature)
##Reset: 0000_0000_0004_0007h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_0840"
	63:24	Reserved.
	23:16	ExtLvtCount: extended local vector table count. Reset: 04h. This specifies the number of extended LVT registers (Core::X86::Msr::ExtendedInterruptLvtEntries) in the local APIC. AccessType: X2APICEN ? Read-only,Error-on-write : Error-on-read,Error-on-write.
	15:3	Reserved.
	2	ExtApicIdCap: extended APIC ID capable. Reset: 1. 1=The processor is capable of supporting an 8-bit APIC ID, as controlled by Core::X86::Msr::ExtendedApicControl[ExtApicIdEn]. AccessType: X2APICEN ? Read-only,Error-on-write : Error-on-read,Error-on-write.
	1	SeoiCap: specific end of interrupt capable. Reset: 1. 1=The Core::X86::Msr::SpecificEndOfInterrupt is present. AccessType: X2APICEN ? Read-only,Error-on-write : Error-on-read,Error-on-write.
	0	IerCap: interrupt enable register capable. Reset: 1. This bit indicates that the Core::X86::Msr::InterruptEnable0 - 7 are present. See 2.1.14.2.1.8 [Interrupt Masking]. AccessType: X2APICEN ? Read-only,Error-on-write : Error-on-read,Error-on-write.

#MSR0000_0841 [Extended APIC Control] (Core::X86::Msr::ExtendedApicControl)
##Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_0841"
	63:3	Reserved.
	2	ExtApicIdEn: extended APIC ID enable. Reset: 0. 1=Enable 8-bit APIC ID; Core::X86::Msr::APIC_ID[ApicId[31:0]] supports an 8-bit value; an interrupt broadcast in physical destination mode requires that the IntDest[7:0]=1111_1111b (instead of xxxx_1111b); a match in physical destination mode occurs when (IntDest[7:0] == ApicId[7:0]) instead of (IntDest[3:0] == ApicId[3:0]). AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.
	1	SeoiEn. Reset: 0. 1=Enable SEOI generation when a write to Core::X86::Msr::SpecificEndOfInterrupt is received. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.
	0	IerEn. Reset: 0. 1=Enable writes to the interrupt enable registers. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.

#MSR0000_0842 [Specific End Of Interrupt] (Core::X86::Msr::SpecificEndOfInterrupt)
##Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_0842"
	63:8	Reserved.
	7:0	"EoiVec: end of interrupt vector. Reset: 00h. A write to this field causes an end of interrupt cycle to be performed for the vector specified in this field. The behavior is undefined if no interrupt is pending for the specified interrupt vector." AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.

#MSR0000_0848 [Interrupt Enable 0] (Core::X86::Msr::InterruptEnable0)
##Reset: 0000_0000_FFFF_FFFFh.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n0_aliasMSR; MSR0000_0848"
	63:32	Reserved.
	31:16	InterruptEnableBits. Reset: FFFFh. The interrupt enable bits can be used to enable each of the 256 interrupts. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.

#MSR0000_084[9...F] [Interrupt Enable 7..1] (Core::X86::Msr::InterruptEnable71)
##Reset: 0000_0000_FFFF_FFFFh.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n1_aliasMSR; MSR0000_0849"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n2_aliasMSR; MSR0000_084A"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n3_aliasMSR; MSR0000_084B"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n4_aliasMSR; MSR0000_084C"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n5_aliasMSR; MSR0000_084D"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n6_aliasMSR; MSR0000_084E"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n7_aliasMSR; MSR0000_084F"
	63:32	Reserved.
	31:0	"InterruptEnableBits. Reset: FFFF_FFFFh. The interrupt enable bits can be used to enable each of the 256 interrupts." AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.

#MSR0000_085[0...3] [Extended Interrupt Local Vector Table] (Core::X86::Msr::ExtendedInterruptLvtEntries)
##Reset: 0000_0000_0001_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n0_aliasMSR; MSR0000_0850"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n1_aliasMSR; MSR0000_0851"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n2_aliasMSR; MSR0000_0852"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n3_aliasMSR; MSR0000_0853"
	63:17	Reserved.
	16	Mask. Reset: 1. 0=Not masked. 1=Masked. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.
	15:13	Reserved.
	12	"DS: interrupt delivery status. Reset: 0. 0=Idle. 1=Send pending. Indicates that the interrupt has not yet been accepted by the core." AccessType: X2APICEN ? Read-write,Volatile : Error-on-read,Error-on-write.
	11	Reserved.
	10:8	MsgType: message type. Reset: 0h. See2.1.14.2.1.14 [Generalized Local Vector Table]. AccessType: X2APICEN ? Read-write : Error-on-read,Error-on-write.
	7:0	Vector. Reset: 00h. Interrupt vector number.

#MSR0000_0C81 [L3 QoS Configuration] (Core::X86::Msr::L3QosCfg1)
###"_ccd[7:0]_lthree0; MSR0000_0C81"
	63:1	Reserved.
	0 CDP.	Read-write. Reset: 0. Code and Data Prioritization Technology enable.

#MSR0000_0C8D [Monitoring Event Select] (Core::X86::Msr::QM_EVTSEL)
###"_ccd[7:0]_lthree0; MSR0000_0C8D"
	63:40	Reserved.
	39:32	RMID. Read-write. Reset: 00h. Resource Monitoring Identifier.
	31:8	Reserved.
	7:0	EventId. Read-write. Reset: 00h. Monitored Event ID.

#MSR0000_0C8E [QOS L3 Counter] (Core::X86::Msr::QM_CTR)
##Read,Error-on-write. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0; MSR0000_0C8E"
	63	"Error. Read,Error-on-write. Reset: 0. Unsupported RMID or event type was written to Core::X86::Msr::QM_EVTSEL."
	62	"Unavailable. Read,Error-on-write. Reset: 0. Data for this RMID is not available or not monitored for this resource or RMID."
	61:0	RmData. Read,Error-on-write. Reset: 0000_0000_0000_0000h. Resource Monitored Data.

#MSR0000_0C8F [Resource Association] (Core::X86::Msr::PQR_ASSOC)
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_0C8F"
	63:36	Reserved.
	35:32	CLOS. Read-write. Reset: 0h. Class of Service.
	31:8	Reserved.
	7:0	RMID. Read-write. Reset: 00h. Resource Monitoring Identifier.

#MSR0000_0C9[0...F] [L3 QOS Allocation Mask] (Core::X86::Msr::L3QosAllocMask)
###"_ccd[7:0]_lthree0_n0; MSR0000_0C90"
###"_ccd[7:0]_lthree0_n1; MSR0000_0C91"
###"_ccd[7:0]_lthree0_n2; MSR0000_0C92"
###"_ccd[7:0]_lthree0_n3; MSR0000_0C93"
###"_ccd[7:0]_lthree0_n4; MSR0000_0C94"
###"_ccd[7:0]_lthree0_n5; MSR0000_0C95"
###"_ccd[7:0]_lthree0_n6; MSR0000_0C96"
###"_ccd[7:0]_lthree0_n7; MSR0000_0C97"
###"_ccd[7:0]_lthree0_n8; MSR0000_0C98"
###"_ccd[7:0]_lthree0_n9; MSR0000_0C99"
###"_ccd[7:0]_lthree0_n10; MSR0000_0C9A"
###"_ccd[7:0]_lthree0_n11; MSR0000_0C9B"
###"_ccd[7:0]_lthree0_n12; MSR0000_0C9C"
###"_ccd[7:0]_lthree0_n13; MSR0000_0C9D"
###"_ccd[7:0]_lthree0_n14; MSR0000_0C9E"
###"_ccd[7:0]_lthree0_n15; MSR0000_0C9F"
	63:16	Reserved.
	15:0	WayMask. Read-write. Reset: FFFFh. L3 way mask used for allocation control.

#MSR0000_0DA0 [Extended Supervisor State] (Core::X86::Msr::XSS)
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSR0000_0DA0"
	63:13	Reserved.
	12	CET_S. Read-write. Reset: 0. System Control-flow Enforcement Technology.
	11	CET_U. Read-write. Reset: 0. User Control-flow Enforcement Technology.
	10:0	Reserved.

#MSRC000_0080 [Extended Feature Enable] (Core::X86::Msr::EFER)
##SKINIT Execution: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC000_0080"
	63:19	Reserved.
	18	IntWbinvdEn. Read-write. Reset: 0. Interruptible wbinvd, wbnoinvd enable.
	17	"MCOMMIT: enable memory commit instruction. Read-write. Reset: 0. 0=The MCOMMIT opcode is treated as an undefined opcode. 1=The MCOMMIT instruction is enabled. Enable MCOMMIT instruction. See Core::X86::Cpuid::FeatureExtIdEbx[MCOMMIT]."
	16	Reserved.
	15	"TCE: translation cache extension enable. Read-write. Reset: 0. 1=Translation cache extension is enabled. PDC entries related to the linear address of the INVLPG instruction are invalidated. If this bit is 0 all PDC entries are invalidated by the INVLPG instruction."
	14	"FFXSE: fast FXSAVE/FRSTOR enable. Read-write. Reset: 0. 1=Enables the fast FXSAVE/FRSTOR mechanism. A 64-bit operating system may enable the fast FXSAVE/FRSTOR mechanism if (Core::X86::Cpuid::FeatureExtIdEdx[FFXSR] == 1). This bit is set once by the operating system and its value is not changed afterwards."
	13	"LMSLE: long mode segment limit enable. Read-only,Error-on-write-1. Reset: Fixed,0. 1=Enables the long mode segment limit check mechanism."
	12	SVME: secure virtual machine (SVM) enable. Reset: Fixed,0. 1=SVM features are enabled. AccessType: Core::X86::Msr::VM_CR[SvmeDisable] ? Read-only,Error-on-write-1 : Read-write.
	11	NXE: no-execute page enable. Read-write. Reset: 0. 1=The no-execute page protection feature is enabled.
	10	"LMA: long mode active. Read-only. Reset: 0. 1=Indicates that long mode is active. When writing the EFER register the value of this bit must be preserved. Software must read the EFER register to determine the value of LMA, change any other bits as required and then write the EFER register. An attempt to write a value that differs from the state determined by hardware results in a #GP fault."
	9	Reserved.
	8	LME: long mode enable. Read-write. Reset: 0. 1=Long mode is enabled.
	7:1	Reserved.
	0	SYSCALL: system call extension enable. Read-write. Reset: 0. 1=SYSCALL and SYSRET instructions are enabled. This adds the SYSCALL and SYSRET instructions which can be used in flat addressed operating systems as low latency system calls and returns.

#MSRC000_0081 [SYSCALL Target Address] (Core::X86::Msr::STAR)
##Read-write. Reset: 0000_0000_0000_0000h. "This register holds the target address used by the SYSCALL instruction and the code and stack segment selector bases used by the SYSCALL and SYSRET instructions."
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC000_0081"
	63:48	SysRetSel. Read-write. Reset: 0000h. SYSRET CS and SS.
	31:0	Target. Read-write. Reset: 0000_0000h. SYSCALL target address.

#MSRC000_0082 [Long Mode SYSCALL Target Address] (Core::X86::Msr::STAR64)
##Read-write. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC000_0082"
	63:0	"LSTAR: long mode target address. Read-write. Reset: 0000_0000_0000_0000h. Target address for 64-bit mode calling programs. The address stored in this register must be in canonical form (if not canonical, a #GP fault occurs)."

#MSRC000_0083 [Compatibility Mode SYSCALL Target Address] (Core::X86::Msr::STARCOMPAT)
##Read-write. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC000_0083"
	63:0	CSTAR: compatibility mode target address. Read-write. Reset: 0000_0000_0000_0000h. Target address for compatibility mode. The address stored in this register must be in canonical form (if not canonical, a #GP fault occurs).

#MSRC000_0084 [SYSCALL Flag Mask] (Core::X86::Msr::SYSCALL_FLAG_MASK)
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC000_0084"
	63:32	Reserved.
	31:0	"Mask: SYSCALL flag mask. Read-write. Reset: 0000_0000h. This register holds the EFLAGS mask used by the SYSCALL instruction. 1=Clear the corresponding EFLAGS bit when executing the SYSCALL instruction."

#MSRC000_00E7 [Read-Only Max Performance Frequency Clock Count] (Core::X86::Msr::MPerfReadOnly)
##Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC000_00E7"
	63:0	"MPerfReadOnly: read-only maximum core clocks counter. Reset: 0000_0000_0000_0000h. Incremented by hardware at the P0 frequency while the core is in C0. In combination with Core::X86::Msr::APerfReadOnly, this is used to determine the effective frequency of the core. A Read of this MSR in guest mode is affected by Core::X86::Msr::TscRateMsr. This field uses software P-state numbering. See Core::X86::Msr::HWCR[EffFreqCntMwait], 2.1.6 [Effective Frequency]. This register is not affected by writes to Core::X86::Msr::MPERF." "AccessType: Core::X86::Msr::HWCR[EffFreqReadOnlyLock] ? Read,Error-on-write,Volatile : Read- write,Volatile."

#MSRC000_00E8 [Read-Only Actual Performance Frequency Clock Count] (Core::X86::Msr::APerfReadOnly)
##Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC000_00E8"
	63:0	"APerfReadOnly: read-only actual core clocks counter. Reset: 0000_0000_0000_0000h. This register increments in proportion to the actual number of core clocks cycles while the core is in C0. See Core::X86::Msr::MPerfReadOnly. This register is not affected by writes to Core::X86::Msr::APERF."

#MSRC000_00E9 [Instructions Retired Performance Count] (Core::X86::Msr::IRPerfCount)
##Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC000_00E9"
	63:48	Reserved.
	47:0	"IRPerfCount: instructions retired counter. Reset: 0000_0000_0000h. Dedicated Instructions Retired register increments on once for every instruction retired. See Core::X86::Msr::HWCR[IRPerfEn]." "AccessType: Core::X86::Msr::HWCR[EffFreqReadOnlyLock] ? Read,Error-on-write,Volatile : Read- write,Volatile."

#MSRC000_0100 [FS Base] (Core::X86::Msr::FS_BASE)
##Read-write. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC000_0100"
	63:0	"FSBase: expanded FS segment base. Read-write. Reset: 0000_0000_0000_0000h. This register provides access to the expanded 64-bit FS segment base. The address stored in this register must be in canonical form (if not canonical, a #GP fault fill occurs)."

#MSRC000_0101 [GS Base] (Core::X86::Msr::GS_BASE)
##Read-write. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC000_0101"
	63:0	GSBase: expanded GS segment base. Read-write. Reset: 0000_0000_0000_0000h. This register provides access to the expanded 64-bit GS segment base. The address stored in this register must be in canonical form (if not canonical, a #GP fault fill occurs).

#MSRC000_0102 [Kernel GS Base] (Core::X86::Msr::KernelGSbase)
##Read-write. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC000_0102"
	63:0	KernelGSBase: kernel data structure pointer. Read-write. Reset: 0000_0000_0000_0000h. This register holds
the kernel data structure pointer which can be swapped with the GS_BASE register using the SwapGS instruction.
The address stored in this register must be in canonical form (if not canonical, a #GP fault occurs).

#MSRC000_0103 [Auxiliary Time Stamp Counter] (Core::X86::Msr::TSC_AUX)
##Read-write,Volatile. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC000_0103"
	63:32	Reserved.
	31:0	"TscAux: auxiliary time stamp counter data. Read-write,Volatile. Reset: 0000_0000h. It is expected that this is initialized by privileged software to a meaningful value, such as a processor ID. This value is returned in the RDTSCP instruction."

#MSRC000_0104 [Time Stamp Counter Ratio] (Core::X86::Msr::TscRateMsr)
##"Core::X86::Msr::TscRateMsr allows the hypervisor to control the guest's view of the Time Stamp Counter. It provides a multiplier that scales the value returned when Core::X86::Msr::TSC[TSC], Core::X86::Msr::MPERF[MPERF], and Core::X86::Msr::MPerfReadOnly[MPerfReadOnly] are read by a guest running under virtualization. This allows the hypervisor to provide a consistent TSC, MPERF, and MPerfReadOnly rate for a guest process when moving that process between cores that have a differing P0 rate. The TSC Ratio MSR does not affect the value read from the TSC, MPERF, and MPerfReadOnly MSRs when read when in host mode or when virtualization is not being used or when accessed by code executed in system management mode (SMM) unless the SMM code is executed within a guest container. The TSC Ratio value does not affect the rate of the underlying TSC, MPERF, and MPerfReadOnly counters, or the value that gets written to the TSC, MPERF, and MPerfReadOnly MSRs counters on a write by either the host or the guest. The TSC Ratio MSR contains a fixed-point number in 8.32 format, which is 8 bits of integer and 32 bits of fraction. This number is the ratio of the desired P0 frequency to the P0 frequency of the core. The reset value of the TSC Ratio MSR is 1.0, which results in a guest frequency matches the core P0 frequency."
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC000_0104"
	63:40	Reserved.
	39:32	"TscRateMsrInt: time stamp counter rate integer. Read-write. Reset: 01h. Specifies the integer part of the MSR TSC ratio value."
	31:0	"TscRateMsrFrac: time stamp counter rate fraction. Read-write. Reset: 0000_0000h. Specifies the fractional part of the MSR TSC ratio value."

#MSRC000_0108 [Prefetch Control] (Core::X86::Msr::PrefetchControl)
##Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]; MSRC000_0108"
	63:6	Reserved.
	5	"UpDown. Read-write. Reset: 0. Disable prefetcher that uses memory access history to determine whether to fetch the next or previous line into L2 cache for all memory accesses."
	4	Reserved.
	3	"L2Stream. Read-write. Reset: 0. Disable prefetcher that uses history of memory access patterns to fetch additional sequential lines into L2 cache."
	2	"L1Region. Read-write. Reset: 0. Disable prefetcher that uses memory access history to fetch additional lines into L1 cache when the data access for a given instruction tends to be followed by a consistent pattern of other accesses within a localized region."
	1	"L1Stride. Read-write. Reset: 0. Disable stride prefetcher that uses memory access history of individual instructions to fetch additional lines into L1 cache when each access is a constant distance from the previous."
	0	"L1Stream. Read-write. Reset: 0. Disable stream prefetcher that uses history of memory access patterns to fetch additional sequential lines into L1 cache."

#MSRC000_010F [Debug Extension Configuration] (Core::X86::Msr::DbgExtnCfg)
##Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC000_010F"
	63:27	Reserved.
	26:24	"PMC. Read-write. Reset: 0h. PMC number that is programmed to overflow. See Core::X86::Msr::PERF_CTL0..5."
	23:20	Reserved.
	19:16	MSROFF. Read-write. Reset: 0h. "Description: Offset in the MSR map for the next recorded branch. Indicates the first sampling pair of MSRs that the processor should fill with branch records. It will proceed from that specified pair to Core::X86::Msr::SAMP_BR_FROM/TO[N-1] and then stop recording. When it stops recording by reaching the last entry, the HW sets MSROFF = 0. If software disables branch sampling while recording is active, MSROFF contains the next Core::X86::Msr::SAMP_BR_FROM/TO MSR that would have been updated. Therefore Core::X86::Msr::SAMP_BR_FROM/TO_0 to SAMP_BR_FROM/TO_(MSROFF-1) should contain valid branch records if VB == 1."
	15:6	Reserved.
	5	"VB. Read-write. Reset: 0. Valid Branches are recorded in the MSRs. See Core::X86::Msr::SAMP_BR_FROM and Core::X86::Msr::SAMP_BR_TO."
	4:3	RSVD4_3. Read-write. Reset: 0h. Write 11b when setting BRSMEN.
	2	"BRSMEN. Read-write. Reset: 0. Branch Sampling Mode ENable. When set, branch recording is enabled. RSVD4_3 also needs to be written with 11b when this bit is set."
	1:0	Reserved.

#MSRC000_020[0...F] [L3 QOS Bandwidth Control] (Core::X86::Msr::L3QosBwControl)
###"_ccd[7:0]_lthree0_n0; MSRC000_0200"
###"_ccd[7:0]_lthree0_n1; MSRC000_0201"
###"_ccd[7:0]_lthree0_n2; MSRC000_0202"
###"_ccd[7:0]_lthree0_n3; MSRC000_0203"
###"_ccd[7:0]_lthree0_n4; MSRC000_0204"
###"_ccd[7:0]_lthree0_n5; MSRC000_0205"
###"_ccd[7:0]_lthree0_n6; MSRC000_0206"
###"_ccd[7:0]_lthree0_n7; MSRC000_0207"
###"_ccd[7:0]_lthree0_n8; MSRC000_0208"
###"_ccd[7:0]_lthree0_n9; MSRC000_0209"
###"_ccd[7:0]_lthree0_n10; MSRC000_020A"
###"_ccd[7:0]_lthree0_n11; MSRC000_020B"
###"_ccd[7:0]_lthree0_n12; MSRC000_020C"
###"_ccd[7:0]_lthree0_n13; MSRC000_020D"
###"_ccd[7:0]_lthree0_n14; MSRC000_020E"
###"_ccd[7:0]_lthree0_n15; MSRC000_020F"
	63:12	Reserved.
	11:0	Ceiling. Read-write. Reset: 800h. QOS Bandwidth Control bandwidth ceiling value.

#MSRC000_0410 [MCA Interrupt Configuration] (Core::X86::Msr::McaIntrCfg)
##Read-write. Reset: 0000_0000_0000_0000h.
	63:16	Reserved.
	15:12	ThresholdLvtOffset. Read-write. Reset: 0h. For error thresholding interrupts, specifies the address of the LVT entry in the APIC registers as follows: LVT address = (LvtOffset shifted left 4 bits) + 500h (see Core::X86::Apic::ExtendedInterruptLvtEntries).
	11:8	Reserved.
	7:4	DeferredLvtOffset. Read-write. Reset: 0h. Description: For deferred error interrupts, specifies the address of the LVT entry in the APIC registers as follows: LVT address = (LvtOffset shifted left 4 bits) + 500h (see APIC[530:500]).
	3:0	Reserved.

#MSRC001_0000 [Performance Event Select 0] (Core::X86::Msr::PERF_LEGACY_CTL0)
##Read-write. Reset: 0000_0000_0000_0000h. The legacy alias of Core::X86::Msr::PERF_CTL0. See Core::X86::Msr::PERF_CTL0.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_0000"
	63:42	Reserved.
	41:40	HostGuestOnly: count only host/guest events. Read-write. Reset: 0h.
ValidValues:
0h Count all events, irrespective of guest/host.
1h Count guest events if [SVME] == 1.
2h Count host events if [SVME] == 1.
3h Count all guest and host events if [SVME] == 1.
ValidValuesEnd
	39:36	Reserved.
	35:32	EventSelect[11:8]. Read-write. Reset: 0h. Performance event select[11:8].
	31:24	CntMask: counter mask. Read-write. Reset: 00h. Controls the number of events counted per clock cycle.
ValidValues:
00h The corresponding PERF_CTR[5:0] register increments by the number of events occurring in a clock cycle. See 2.1.17.3 [Large Increment per Cycle Events] for events that can increment greater than 15 per cycle.
7Fh-01h When Inv == 0, the corresponding PERF_CTR[5:0] register increments by 1, if the number of events occurring in a clock cycle is greater than or equal to the CntMask value. When Inv == 1, the corresponding PERF_CTR[5:0] register increments by 1, if the number of events occurring in a clock cycle is less than CntMask value.
FFh-80h Reserved.
ValidValuesEnd
	23	Inv: invert counter mask. Read-write. Reset: 0. See CntMask.
	22	En: enable performance counter. Read-write. Reset: 0. 1=Performance event counter is enabled.
	21	Reserved.
	20	Int: enable APIC interrupt. Read-write. Reset: 0. 1=APIC performance counter LVT interrupt is enabled to generate an interrupt via Core::X86::Apic::PerformanceCounterLvtEntry when the performance counter overflows.
	19	Reserved.
	18	Edge: edge detect. Read-write. Reset: 0. 0=Level detect. 1=Zero-to-one Edge detect. The edge count mode increments the counter when a transition happens on the monitored event. If the event selected is changed without disabling the counter, an extra edge is falsely detected when the first event is a static 0 and the second event is a static one. To avoid this false edge detection, disable the counter when changing the event and then enable the counter with a second MSR write.
	17:16	OsUserMode: OS and user mode. Read-write. Reset: 0h.
ValidValues:
0h Count no events.
1h Count user events (CPL>0).
2h Count OS events (CPL=0).
3h Count all events, irrespective of the CPL.
ValidValuesEnd
	15:8	UnitMask: event qualification. Read-write. Reset: 00h. Each UnitMask bit further specifies or qualifies the event specified by EventSelect. All events selected by UnitMask are simultaneously monitored. Unless otherwise stated, the UnitMask values shown may be combined (logically ORed) to select any desired combination of the sub-events for a given event. In some cases, certain combinations can result in misleading counts, or the UnitMask value is an ordinal rather than a bit mask. These situations are described where applicable, or should be obvious from the event descriptions. For events where no UnitMask table is shown, the UnitMask is Unused.
	7:0	EventSelect[7:0]: event select. Read-write. Reset: 00h. EventSelect[11:0] = {EventSelect[11:8], EventSelect[7:0]}. EventSelect specifies the event or event duration in a processor unit to be counted by the corresponding PERF_CTR[5:0] register. The events are specified in 2.1.17.4 [Core Performance Monitor Counters]. Some events are Reserved; when a Reserved event is selected, the results are undefined.

#MSRC001_0001 [Performance Event Select 1] (Core::X86::Msr::PERF_LEGACY_CTL1)
##Read-write. Reset: 0000_0000_0000_0000h. The legacy alias of Core::X86::Msr::PERF_CTL1. See Core::X86::Msr::PERF_CTL1.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_0001"
	63:42	Reserved.
	41:40	HostGuestOnly: count only host/guest events. Read-write. Reset: 0h.
ValidValues:
0h Count all events, irrespective of guest/host.
1h Count guest events if [SVME] == 1.
2h Count host events if [SVME] == 1.
3h Count all guest and host events if [SVME] == 1.
ValidValuesEnd
	39:36	Reserved.
	35:32	EventSelect[11:8]. Read-write. Reset: 0h. Performance event select[11:8].
	31:24	CntMask: counter mask. Read-write. Reset: 00h. Controls the number of events counted per clock cycle.
ValidValues:
00h The corresponding PERF_CTR[5:0] register increments by the number of events occurring in a clock cycle. See 2.1.17.3 [Large Increment per Cycle Events] for events that can increment greater than 15 per cycle.
7Fh-01h When Inv == 0, the corresponding PERF_CTR[5:0] register increments by 1 if the number of events occurring in a clock cycle is greater than or equal to the CntMask value. When Inv == 1, the corresponding PERF_CTR[5:0] register increments by 1 if the number of events occurring in a clock cycle is less than CntMask value.
FFh-80h Reserved.
ValidValuesEnd
	23	Inv: invert counter mask. Read-write. Reset: 0. See CntMask.
	22	En: enable performance counter. Read-write. Reset: 0. 1=Performance event counter is enabled.
	21	Reserved.
	20	Int: enable APIC interrupt. Read-write. Reset: 0. 1=APIC performance counter LVT interrupt is enabled to generate an interrupt via Core::X86::Apic::PerformanceCounterLvtEntry when the performance counter overflows.
	19	Reserved.
	18	Edge: edge detect. Read-write. Reset: 0. 0=Level detect. 1=Zero-to-one Edge detect. The edge count mode increments the counter when a transition happens on the monitored event. If the event selected is changed without disabling the counter, an extra edge is falsely detected when the first event is a static 0 and the second event is a static one. To avoid this false edge detection, disable the counter when changing the event and then enable the counter with a second MSR write.
	17:16	OsUserMode: OS and user mode. Read-write. Reset: 0h.
ValidValues:
0h Count no events.
1h Count user events (CPL>0).
2h Count OS events (CPL=0).
3h Count all events, irrespective of the CPL.
ValidValuesEnd
	15:8	UnitMask: event qualification. Read-write. Reset: 00h. Each UnitMask bit further specifies or qualifies the event specified by EventSelect. All events selected by UnitMask are simultaneously monitored. Unless otherwise stated, the UnitMask values shown may be combined (logically ORed) to select any desired combination of the sub-events for a given event. In some cases, certain combinations can result in misleading counts, or the UnitMask value is an ordinal rather than a bit mask. These situations are described where applicable, or should be obvious from the event descriptions. For events where no UnitMask table is shown, the UnitMask is Unused.
	7:0	EventSelect[7:0]: event select. Read-write. Reset: 00h. EventSelect[11:0] = {EventSelect[11:8], EventSelect[7:0]}. EventSelect specifies the event or event duration in a processor unit to be counted by the corresponding PERF_CTR[5:0] register. The events are specified in 2.1.17.4 [Core Performance Monitor Counters]. Some events are Reserved; when a Reserved event is selected, the results are undefined.

#MSRC001_0002 [Performance Event Select 2] (Core::X86::Msr::PERF_LEGACY_CTL2)
##Read-write. Reset: 0000_0000_0000_0000h. The legacy alias of Core::X86::Msr::PERF_CTL2. See Core::X86::Msr::PERF_CTL2.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_0002"
	63:42	Reserved.
	41:40	HostGuestOnly: count only host/guest events. Read-write. Reset: 0h.
ValidValues:
0h Count all events, irrespective of guest/host.
1h Count guest events if [SVME] == 1.
2h Count host events if [SVME] == 1.
3h Count all guest and host events if [SVME] == 1.
ValidValuesEnd
	39:36	Reserved.
	35:32	EventSelect[11:8]. Read-write. Reset: 0h. Performance event select[11:8].
	31:24	CntMask: counter mask. Read-write. Reset: 00h. Controls the number of events counted per clock cycle.
ValidValues:
00h The corresponding PERF_CTR[5:0] register increments by the number of events occurring in a clock cycle. See 2.1.17.3 [Large Increment per Cycle Events] for events that can increment greater than 15 per cycle.
7Fh-01h When Inv == 0, the corresponding PERF_CTR[5:0] register increments by 1, if the number of events occurring in a clock cycle is greater than or equal to the CntMask value. When Inv == 1, the corresponding PERF_CTR[5:0] register increments by 1, if the number of events occurring in a clock cycle is less than CntMask value.
FFh-80h Reserved.
ValidValuesEnd
	23	Inv: invert counter mask. Read-write. Reset: 0. See CntMask.
	22	En: enable performance counter. Read-write. Reset: 0. 1=Performance event counter is enabled.
	21	Reserved.
	20	Int: enable APIC interrupt. Read-write. Reset: 0. 1=APIC performance counter LVT interrupt is enabled to generate an interrupt via Core::X86::Apic::PerformanceCounterLvtEntry when the performance counter overflows.
	19	Reserved.
	18	Edge: edge detect. Read-write. Reset: 0. 0=Level detect. 1=Zero-to-one Edge detect. The edge count mode increments the counter when a transition happens on the monitored event. If the event selected is changed without disabling the counter, an extra edge is falsely detected when the first event is a static 0 and the second event is a static one. To avoid this false edge detection, disable the counter when changing the event and then enable the counter with a second MSR write.
	17:16	OsUserMode: OS and user mode. Read-write. Reset: 0h.
ValidValues:
0h Count no events.
1h Count user events (CPL>0).
2h Count OS events (CPL=0).
3h Count all events, irrespective of the CPL.
ValidValuesEnd
	15:8	UnitMask: event qualification. Read-write. Reset: 00h. Each UnitMask bit further specifies or qualifies the event specified by EventSelect. All events selected by UnitMask are simultaneously monitored. Unless otherwise stated, the UnitMask values shown may be combined (logically ORed) to select any desired combination of the sub-events for a given event. In some cases, certain combinations can result in misleading counts, or the UnitMask value is an ordinal rather than a bit mask. These situations are described where applicable, or should be obvious from the event descriptions. For events where no UnitMask table is shown, the UnitMask is Unused.
	7:0	EventSelect[7:0]: event select. Read-write. Reset: 00h. EventSelect[11:0] = {EventSelect[11:8], EventSelect[7:0]}. EventSelect specifies the event or event duration in a processor unit to be counted by the corresponding PERF_CTR[5:0] register. The events are specified in 2.1.17.4 [Core Performance Monitor Counters]. Some events are Reserved; when a Reserved event is selected, the results are undefined.

#MSRC001_0003 [Performance Event Select 3] (Core::X86::Msr::PERF_LEGACY_CTL3)
##Read-write. Reset: 0000_0000_0000_0000h. The legacy alias of Core::X86::Msr::PERF_CTL3. See Core::X86::Msr::PERF_CTL3.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_0003"
	63:42	Reserved.
	41:40	HostGuestOnly: count only host/guest events. Read-write. Reset: 0h.
ValidValues:
0h Count all events, irrespective of guest/host.
1h Count guest events if [SVME] == 1.
2h Count host events if [SVME] == 1.
3h Count all guest and host events if [SVME] == 1.
ValidValuesEnd
	39:36	Reserved.
	35:32	EventSelect[11:8]. Read-write. Reset: 0h. Performance event select[11:8].
	31:24	CntMask: counter mask. Read-write. Reset: 00h. Controls the number of events counted per clock cycle.
ValidValues:
00h The corresponding PERF_CTR[5:0] register increments by the number of events occurring in a clock cycle. See 2.1.17.3 [Large Increment per Cycle Events] for events that can increment greater than 15
per cycle.
7Fh-01h When Inv == 0, the corresponding PERF_CTR[5:0] register increments by 1, if the number of events occurring in a clock cycle is greater than or equal to the CntMask value. When Inv == 1, the corresponding PERF_CTR[5:0] register increments by 1, if the number of events occurring in a clock cycle is less than CntMask value.
FFh-80h Reserved.
ValidValuesEnd
	23	Inv: invert counter mask. Read-write. Reset: 0. See CntMask.
	22	En: enable performance counter. Read-write. Reset: 0. 1=Performance event counter is enabled.
	21	Reserved.
	20	Int: enable APIC interrupt. Read-write. Reset: 0. 1=APIC performance counter LVT interrupt is enabled to generate an interrupt via Core::X86::Apic::PerformanceCounterLvtEntry when the performance counter overflows.
	19	Reserved.
	18	Edge: edge detect. Read-write. Reset: 0. 0=Level detect. 1=Zero-to-one Edge detect. The edge count mode increments the counter when a transition happens on the monitored event. If the event selected is changed without disabling the counter, an extra edge is falsely detected when the first event is a static 0 and the second event is a static one. To avoid this false edge detection, disable the counter when changing the event and then enable the counter with a second MSR write.
	17:16	OsUserMode: OS and user mode. Read-write. Reset: 0h.
ValidValues:
0h Count no events.
1h Count user events (CPL>0).
2h Count OS events (CPL=0).
3h Count all events, irrespective of the CPL.
ValidValuesEnd
	15:8	UnitMask: event qualification. Read-write. Reset: 00h. Each UnitMask bit further specifies or qualifies the event specified by EventSelect. All events selected by UnitMask are simultaneously monitored. Unless otherwise "stated, the UnitMask values shown may be combined (logically ORed) to select any desired combination of the sub-events for a given event. In some cases, certain combinations can result in misleading counts, or the UnitMask value is an ordinal rather than a bit mask. These situations are described where applicable, or should be obvious from the event descriptions. For events where no UnitMask table is shown, the UnitMask is Unused."
	7:0	"EventSelect[7:0]: event select. Read-write. Reset: 00h. EventSelect[11:0] = {EventSelect[11:8], EventSelect[7:0]}. EventSelect specifies the event or event duration in a processor unit to be counted by the corresponding PERF_CTR[5:0] register. The events are specified in 2.1.17.4 [Core Performance Monitor Counters]. Some events are Reserved; when a Reserved event is selected, the results are undefined."

#MSRC001_000[4...7] [Performance Event Counter [3:0]] (Core::X86::Msr::PERF_LEGACY_CTR)
##Read-write,Volatile. Reset: 0000_0000_0000_0000h. "Note: When counting events that capable of counting greater than 15 events per cycle (MergeEvent) the even and the corresponding odd PERF_LEGACY_CTR must be paired to appear as a single 64-bit counter. See 2.1.17.3 [Large Increment per Cycle Events]. The legacy alias of Core::X86::Msr::PERF_CTR. See Core::X86::Msr::PERF_CTR."
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n0; MSRC001_0004"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n1; MSRC001_0005"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n2; MSRC001_0006"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n3; MSRC001_0007"
	63:48	Reserved.
	47:0	CTR. Read-write,Volatile. Reset: 0000_0000_0000h. Performance counter value.

#MSRC001_0010 [System Configuration] (Core::X86::Msr::SYS_CFG)
##Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]; MSRC001_0010"
	63:26	Reserved.
	25	VmplEn. Reset: 0. VM permission levels enable. AccessType: Core::X86::Msr::SYS_CFG[SecureNestedPagingEn] ? Read-only : Read-write.
	24	SecureNestedPagingEn. Read,Write-1-only. Reset: 0. Enable Secure Nested Paging (SNP).
	23	"SMEE: secure memory encryption enable. Read,Write-1-only. Reset: 0. 0=Memory encryption features are disabled. 1=Memory encryption features are enabled. For enabling secure memory encryption see 2.1.4 [Memory Encryption]."
	22	"Tom2ForceMemTypeWB: top of memory 2 memory type write back. Read-write. Reset: 0. 1=The default memory type of memory between 4-GB and Core::X86::Msr::TOM2 is write back instead of the memory type defined by Core::X86::Msr::MTRRdefType[MemType]. For this bit to have any effect, Core::X86::Msr::MTRRdefType[MtrrDefTypeEn] must be 1. MTRRs and PAT can be used to override this memory type."
	21	"MtrrTom2En: MTRR top of memory 2 enable. Read-write. Reset: 0. 0=Core::X86::Msr::TOM2 is disabled. 1= Core::X86::Msr::TOM2 is enabled."
	20	"MtrrVarDramEn: MTRR variable DRAM enable. Read-write. Reset: 0. Init: BIOS,1. 0=Core::X86::Msr::TOP_MEM and IORRs are disabled. 1=These registers are enabled."
	19	"MtrrFixDramModEn: MTRR fixed RdDram and WrDram modification enable. Read-write. Reset: 0. 0=Core::X86::Msr::MtrrFix_64K through Core::X86::Msr::MtrrFix_4K_7 [RdDram,WrDram] read values is masked 00b; writing does not change the hidden value. 1=Core::X86::Msr::MtrrFix_64K through Core::X86::Msr::MtrrFix_4K_7 [RdDram,WrDram] access type is Read-write. Not shared between threads. Controls access to Core::X86::Msr::MtrrFix_64K through Core::X86::Msr::MtrrFix_4K_7 [RdDram ,WrDram]. This bit should be set to 1 during BIOS initialization of the fixed MTRRs, then cleared to 0 for operation."
	17:0	Reserved.

#MSRC001_0015 [Hardware Configuration] (Core::X86::Msr::HWCR)
##Reset: 0000_0000_0100_0010h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_0015"
	63:34	Reserved.
	33	"SmmPgCfgLock. Read-write. Reset: 0. 1=SMM page config locked. Error-on-write-1 if not in SMM mode. RSM unconditionally clears Core::X86::Msr::HWCR[SmmPgCfgLock]."
	32:31	Reserved.
	30	IRPerfEn: enable instructions retired counter. Read-write. Reset: 0. 1=Enable Core::X86::Msr::IRPerfCount.
	29:28	Reserved.
	27	"EffFreqReadOnlyLock: read-only effective frequency counter lock. Write-1-only. Reset: 0. Init: BIOS,1. 1=Core::X86::Msr::MPerfReadOnly, Core::X86::Msr::APerfReadOnly and Core::X86::Msr::IRPerfCount are Read-only."
	26	"EffFreqCntMwait: effective frequency counting during mwait. Read-write. Reset: 0. 0=The registers do not increment. 1=The registers increment. Specifies whether Core::X86::Msr::MPERF and Core::X86::Msr::APERF increment while the core is in the monitor event pending state. See 2.1.6 [Effective Frequency]."
	25	"CpbDis: core performance boost disable. Read-write. Reset: 0. 0=CPB is requested to be enabled. 1=CPB is disabled. Specifies whether core performance boost is requested to be enabled or disabled. If core performance boost is disabled while a core is in a boosted P-state, the core automatically transitions to the highest performance non-boosted P-state."
	24	TscFreqSel: TSC frequency select. Read-only. Reset: 1. 1=The TSC increments at the P0 frequency.
	23:22	Reserved.
	21	"LockTscToCurrentP0: lock the TSC to the current P0 frequency. Read-write. Reset: 0. 0=The TSC will count at the P0 frequency. 1=The TSC frequency is locked to the current P0 frequency at the time this bit is set and remains fixed regardless of future changes to the P0 frequency."
	20	"IoCfgGpFault: IO-space configuration causes a GP fault. Read-write. Reset: 0. 1=IO-space accesses to configuration space cause a GP fault. The fault is triggered if any part of the IO Read/Rrite address range is between CF8h and CFFh, inclusive. These faults only result from single IO instructions, not to string and REP IO instructions. This fault takes priority over the IO trap mechanism described by Core::X86::Msr::SMI_ON_IO_TRAP_CTL_STS."
	19	Reserved.
	18	"McStatusWrEn: machine check status write enable. Read-write. Reset: 0. 0=MCA_STATUS registers are Readable; Writing a non-zero pattern to these registers causes a general protection fault. 1=MCA_STATUS registers are Read-write, including Reserved fields; do not cause general protection faults; such Writes update all implemented bits in these registers; All fields of all threshold registers are Read-write when accessed from MSR space, including Locked, except BlkPtr which is always Read-only; McStatusWrEn does not change the access type for the thresholding registers accessed via configuration space." "Description: McStatusWrEn can be used to debug machine check exception and interrupt handlers. Independent of the value of this bit, the processor may enforce Write-Ignored behavior on MCA_STATUS registers depending on platform settings. See 3.1 [Machine Check Architecture]."
	17	"Wrap32Dis: 32-bit address wrap disable. Read-write. Reset: 0. 1=Disable 32-bit address wrapping. Software can use Wrap32Dis to access physical memory above 4 Gbytes without switching into 64-bit mode. To do so, software should Write a greater-than 4-Gbyte address to Core::X86::Msr::FS_BASE and Core::X86::Msr::GS_BASE. Then it would address ±2 Gbytes from one of those bases using normal memory reference instructions with a FS or GS override prefix. However, the INVLPG, FST, and SSE store instructions generate 32-bit addresses in legacy mode, regardless of the state of Wrap32Dis."
	16:15	Reserved.
	14	RsmSpCycDis: RSM special bus cycle disable. Reset: 0. Init: BIOS,1. 0=A link special bus cycle, SMIACK, is generated on a resume from SMI. AccessType: Core::X86::Msr::HWCR[SmmLock] ? Read-only : Read-write.
	13	"SmiSpCycDis: SMI special bus cycle disable. Reset: 0. Init: BIOS,1. 0=A link special bus cycle, SMIACK, is generated when an SMI interrupt is taken." AccessType: Core::X86::Msr::HWCR[SmmLock] ? Read-only : Read-write.
	12:11	Reserved.
	10	"MonMwaitUserEn: MONITOR/MWAIT user mode enable. Read-write. Reset: 0. 0=The MONITOR and MWAIT instructions are supported only in privilege level 0; these instructions in privilege levels 1 to 3 cause a #UD exception. 1=The MONITOR and MWAIT instructions are supported in all privilege levels. The state of this bit is ignored if MonMwaitDis is set."
	9	"MonMwaitDis: MONITOR and MWAIT disable. Read-write. Reset: 0. 1=The MONITOR, MWAIT, MONITORX, and MWAITX opcodes become invalid. This affects what is reported back through Core::X86::Cpuid::FeatureIdEcx[Monitor] and Core::X86::Cpuid::FeatureExtIdEcx[MwaitExtended]."
	8	IgnneEm: IGNNE port emulation enable. Read-write. Reset: 0. 1=Enable emulation of IGNNE port.
	7	"AllowFerrOnNe: allow FERR on NE. Read-write. Reset: 0. 0=Disable legacy FERR signaling and generate FERR exception directly. 1=Legacy FERR signaling."
	6:5	Reserved.
	4	"INVDWBINVD: INVD to WBINVD conversion. Read-write. Reset: 1. Check: 1. 1=Convert INVD to WBINVD." "Description: This bit is required to be set for normal operation when any of the following are true: •An L2 is shared by multiple threads. •An L3 is shared by multiple cores. •CC6 is enabled. •Probe filter is enabled."
	3	"TlbCacheDis: cacheable memory disable. Read-write. Reset: 0. 1=Disable performance improvement that assumes that the PML4, PDP, PDE and PTE entries are in cacheable WB DRAM." "Description: Operating systems that maintain page tables in any other memory type must set the TlbCacheDis bit to insure proper operation. •TlbCacheDis does not override the memory type specified by the SMM ASeg and TSeg memory regions controlled by Core::X86::Msr::SMMAddr Core::X86::Msr::SMMMask."
	2:1	Reserved.
	0	SmmLock: SMM code lock. Read,Write-1-only. Reset: 0. Init: BIOS,1. 1=SMM code in the ASeg and TSeg range and the SMM registers are Read-only and SMI interrupts are not intercepted in SVM. See 2.1.14.1.10 [Locking SMM].

#MSRC001_001[6...8] [IO Range Base] (Core::X86::Msr::IORR_BASE)
##Read-write. "Core::X86::Msr::IORR_BASE and Core::X86::Msr::IORR_MASK combine to specify the two sets of base and mask pairs for two IORR ranges. A core access, with address CPUAddr, is determined to be within IORR address range if the following equation is true: CPUAddr[47:12] & PhyMask[47:12] == PhyBase[47:12] & PhyMask[47:12]. BIOS can use the IORRs to create an IO hole within a range of addresses that would normally be mapped to DRAM. It can also use the IORRs to re-assert a DRAM destination for a range of addresses that fall within a bigger IO hole that overlays DRAM."
###"_ccd[7:0]_lthree0_core[7:0]_n0; MSRC001_0016"
###"_ccd[7:0]_lthree0_core[7:0]_n1; MSRC001_0018"
	63:48	Reserved.
	47:12	PhyBase. Read-write. Reset: X_XXXX_XXXXh. Physical base address for IO range.
	11:5	Reserved.
	4	RdMem: read from memory. Read-write. Reset: X. 0=Read accesses to the range are directed to IO. 1=Read accesses to the range are directed to system memory.
	3	"WrMem: write to memory. Read-write. Reset: X. 0=Write accesses to the range are directed to IO. 1=Write accesses to the range are directed to system memory."
	2:0	Reserved.

#MSRC001_001[7...9] [IO Range Mask] (Core::X86::Msr::IORR_MASK)
##Read-write. Reset: 0000_0000_0000_0000h. See Core::X86::Msr::IORR_BASE.
###"_ccd[7:0]_lthree0_core[7:0]_n0; MSRC001_0017"
###"_ccd[7:0]_lthree0_core[7:0]_n1; MSRC001_0019"
	63:48	Reserved.
	47:12	PhyMask. Read-write. Reset: 0_0000_0000h. Physical address mask for IO range.
	11	Valid. Read-write. Reset: 0. 1=The pair of registers that specifies an IORR range is valid.
	10:0	Reserved.

#MSRC001_001A [Top Of Memory] (Core::X86::Msr::TOP_MEM)
##Read-write.
###"_ccd[7:0]_lthree0_core[7:0]; MSRC001_001A"
	63:48	Reserved.
	47:23	"TOM[47:23]: top of memory. Read-write. Reset: XXX_XXXXh. Specifies the address that divides between MMIO and DRAM. This value is normally placed below 4-GB. From TOM to 4-GB is MMIO; below TOM is DRAM. See 2.1.7.3 [System Address Map]."
	22:0	Reserved.

#MSRC001_001D [Top Of Memory 2] (Core::X86::Msr::TOM2)
##Read-write.
###"_ccd[7:0]_lthree0_core[7:0]; MSRC001_001D"
	63:48	Reserved.
	47:23	"TOM2[47:23]: second top of memory. Read-write. Reset: XXX_XXXXh. Specifies the address divides between MMIO and DRAM. This value is normally placed above 4-GB. From 4-GB to (TOM2 - 1) is DRAM; TOM2 and above is MMIO. See 2.1.7.3 [System Address Map]. This register is enabled by Core::X86::Msr::SYS_CFG[MtrrTom2En]."
	22:0	Reserved.

#MSRC001_0022 [Machine Check Exception Redirection] (Core::X86::Msr::McExcepRedir)
##Read-write. Reset: 0000_0000_0000_0000h. "This register can be used to redirect machine check exceptions (MCEs) to SMIs or vectored interrupts. If both RedirSmiEn and RedirVecEn are set, then undefined behavior results."
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_0022"
	63:10	Reserved.
	9	"RedirSmiEn. Read-write. Reset: 0. 1=Redirect MCEs (that are directed to this core) to generate an SMI-trigger IO cycle via Core::X86::Msr::SmiTrigIoCycle. The status is stored in Core::X86::Smm::LocalSmiStatus[MceRedirSts]."
	8	"RedirVecEn. Read-write. Reset: 0. 1=Redirect MCEs (that are directed to this core) to generate a vectored interrupt, using the interrupt vector specified in RedirVector."
	7:0	RedirVector. Read-write. Reset: 00h. See RedirVecEn.

#MSRC001_003[0...5] [Processor Name String] (Core::X86::Msr::ProcNameString)
##Read-write. "These 6 registers hold the CPUID name string in ASCII. The state of these registers are returned by CPUID instructions, Core::X86::Cpuid::ProcNameStr0Eax through Core::X86::Cpuid::ProcNameStr2Edx. BIOS should set these registers to the product name for the processor as provided by AMD. Each register contains a block of 8 ASCII characters; the least byte corresponds to the first ASCII character of the block; the most-significant byte corresponds to the last character of the block. MSRC001_0030 contains the first block of the name string; MSRC001_0035 contains the last block of the name string."
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n0; MSRC001_0030"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n1; MSRC001_0031"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n2; MSRC001_0032"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n3; MSRC001_0033"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n4; MSRC001_0034"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n5; MSRC001_0035"
	63:56	CpuNameString7. Read-write. Reset: XXh. CPUID name string in ASCII.
	55:48	CpuNameString6. Read-write. Reset: XXh. CPUID name string in ASCII.
	47:40	CpuNameString5. Read-write. Reset: XXh. CPUID name string in ASCII.
	39:32	CpuNameString4. Read-write. Reset: XXh. CPUID name string in ASCII.
	31:24	CpuNameString3. Read-write. Reset: XXh. CPUID name string in ASCII.
	23:16	CpuNameString2. Read-write. Reset: XXh. CPUID name string in ASCII.
	15:8	CpuNameString1. Read-write. Reset: XXh. CPUID name string in ASCII.
	7:0	CpuNameString0. Read-write. Reset: XXh. CPUID name string in ASCII.

#MSRC001_005[0...3] [IO Trap] (Core::X86::Msr::SMI_ON_IO_TRAP)
##Read-write. Reset: 0000_0000_0000_0000h. "Core::X86::Msr::SMI_ON_IO_TRAP and Core::X86::Msr::SMI_ON_IO_TRAP_CTL_STS provide a mechanism for executing the SMI handler if a an access to one of the specified addresses is detected. Access address and access type checking is performed before IO instruction execution. If the access address and access type match one of the specified IO address and access types, then: (1) the IO instruction is not executed; (2) any breakpoint, other than the single-step breakpoint, set on the IO instruction is not taken (the single-step breakpoint is taken after resuming from SMM); and (3) issue the SMI-trigger IO cycle specified by Core::X86::Msr::SmiTrigIoCycle if enabled. The status is stored in Core::X86::Smm::LocalSmiStatus[IoTrapSts]. IO-space configuration accesses are special IO accesses. An IO access is defined as an IO-space configuration access when IO instruction address bits[31:0] are CFCh, CFDh, CFEh, or CFFh when IO-space configuration is enabled (IO::IoCfgAddr[ConfigEn]). The access address for a configuration space access is the current value of IO::IoCfgAddr[BusNo,Device,Function,RegNo]. The access address for an IO access that is not a configuration access is equivalent to the IO instruction address, bits[31:0]. The access address is compared with SmiAddr, and the instruction access type is compared with the enabled access types defined by ConfigSMI, SmiOnRdEn, and SmiOnWrEn. Access address bits[23:0] can be masked with SmiMask. IO and configuration space trapping to SMI applies only to single IO instructions; it does not apply to string and REP IO instructions. The conditional GP fault described by Core::X86::Msr::HWCR[IoCfgGpFault] takes priority over this trap."
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n0; MSRC001_0050"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n1; MSRC001_0051"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n2; MSRC001_0052"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n3; MSRC001_0053"
	63	SmiOnRdEn: enable SMI on IO read. Read-write. Reset: 0. 1=Enables SMI generation on a Read access.
	62	SmiOnWrEn: enable SMI on IO write. Read-write. Reset: 0. 1=Enables SMI generation on a Write access.
	61	"ConfigSmi: configuration space SMI. Read-write. Reset: 0. 0=IO access (that is not an IO-space configuration access). 1=Configuration access."
	60:56	Reserved.
	55:32	SmiMask[23:0]. Read-write. Reset: 00_0000h. 1=Do not mask address bit. 0=Mask address bit. SMI IO trap mask.
	31:0	SmiAddr[31:0]. Read-write. Reset: 0000_0000h. SMI IO trap address.

#MSRC001_0054 [IO Trap Control] (Core::X86::Msr::SMI_ON_IO_TRAP_CTL_STS)
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_0054"
	63:16	Reserved.
	15	"IoTrapEn: IO trap enable. Read-write. Reset: 0. 1=Enable IO and configuration space trapping specified by Core::X86::Msr::SMI_ON_IO_TRAP and Core::X86::Msr::SMI_ON_IO_TRAP_CTL_STS."
	14:8	Reserved.
	7	SmiEn3. Read-write. Reset: 0. 1=The trap Core::X86::Msr::SMI_ON_IO_TRAP_n[3] is enabled.
	6	Reserved.
	5	SmiEn2. Read-write. Reset: 0. 1=The trap Core::X86::Msr::SMI_ON_IO_TRAP_n[2] is enabled.
	4	Reserved.
	3	SmiEn1. Read-write. Reset: 0. 1=The trap Core::X86::Msr::SMI_ON_IO_TRAP_n[1] is enabled.
	2	Reserved.
	1	SmiEn0. Read-write. Reset: 0. 1=The trap Core::X86::Msr::SMI_ON_IO_TRAP_n[0] is enabled.
	0	Reserved.

#MSRC001_0055 [Reserved.] (Core::X86::Msr::IntPend)
##Read-only. Reset: Fixed,0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]; MSRC001_0055"
	63:0	Reserved.

#MSRC001_0056 [SMI Trigger IO Cycle] (Core::X86::Msr::SmiTrigIoCycle)
##Read-write. Reset: 0000_0000_0000_0000h. "See 2.1.14.1.3 [SMI Sources And Delivery]. This register specifies an IO cycle that may be generated when a local SMI trigger event occurs. If IoCycleEn is set and there is a local SMI trigger event, then the IO cycle generated is a byte Read or Write, based on IoRd, to address IoPortAddress. If the cycle is a Write, then IoData contains the data written. If the cycle is a Read, the value read is discarded. If IoCycleEn is clear and a local SMI trigger event occurs, then undefined behavior results."
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_0056"
	63:27	Reserved.
	26	IoRd: IO Read. Read-write. Reset: 0. 0=IO Write. 1=IO Read.
	25	IoCycleEn: IO cycle enable. Read-write. Reset: 0. 1=The SMI trigger IO cycle is enabled to be generated.
	24	Reserved.
	23:16	IoData. Read-write. Reset: 00h. See 2.1.14.1.3 [SMI Sources And Delivery].
	15:0	IoPortAddress. Read-write. Reset: 0000h. See 2.1.14.1.3 [SMI Sources And Delivery].

#MSRC001_0058 [MMIO Configuration Base Address] (Core::X86::Msr::MmioCfgBaseAddr)
##See 2.1.8 [Configuration Space] for a description of MMIO configuration space.
###"_ccd[7:0]_lthree0_core[7:0]; MSRC001_0058"
	63:48	Reserved.
	47:20	"MmioCfgBaseAddr[47:20]: MMIO configuration base address bits[47:20]. Read-write. Reset: XXX_XXXXh. Specifies the base address of the MMIO configuration range."
	19:6	Reserved.
	5:2	"BusRange: bus range identifier. Read-write. Reset: 0h. Specifies the number of buses in the MMIO configuration space range. The size of the MMIO configuration space is 1-MB times the number of buses."
ValidValues:
0h 1
1h 2
2h 4
3h 8
4h 16
5h 32
6h 64
7h 128
8h 256
Fh-9h Reserved.
ValidValuesEnd
	1	Reserved.
	0	Enable. Read-write. Reset: 0. 1=MMIO configuration space is enabled.

#MSRC001_0061 [P-state Current Limit] (Core::X86::Msr::PStateCurLim)
###"_ccd[7:0]_lthree0_core[7:0]; MSRC001_0061"
	63:7	Reserved.
	6:4	PstateMaxVal: P-state maximum value. Read,Error-on-write,Volatile. Reset: XXXb. Specifies the lowest- performance non-boosted P-state (highest non-boosted value) allowed. Attempts to change Core::X86::Msr::PStateCtl[PstateCmd] to a lower-performance P-state (higher value) are clipped to the value of this field.
	3	Reserved.
	2:0	CurPstateLimit: current P-state limit. Read,Error-on-write,Volatile. Reset: XXXb. Specifies the highest-performance P-state (lowest value) allowed. CurPstateLimit is always bounded by Core::X86::Msr::PStateCurLim[PstateMaxVal]. Attempts to change the CurPstateLimit to a value greater (lower performance) than Core::X86::Msr::PStateCurLim[PstateMaxVal] leaves CurPstateLimit unchanged.

#MSRC001_0062 [P-state Control] (Core::X86::Msr::PStateCtl)
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_0062"
	63:3	Reserved.
	2:0	PstateCmd: P-state change command. Read-write. Reset: XXXb. Cold reset value varies by product; after a warm reset, value initializes to the P-state the core was in prior to the reset. Writes to this field cause the core to change to the indicated non-boosted P-state number, specified by Core::X86::Msr::PStateDef. 0=P0, 1=P1, etc. P- state limits are applied to any P-state requests made through this register. Reads from this field return the last written value, regardless of whether any limits are applied.

#MSRC001_0063 [P-state Status] (Core::X86::Msr::PStateStat)
##Read,Error-on-write,Volatile.
###"_ccd[7:0]_lthree0_core[7:0]; MSRC001_0063"
	63:3	Reserved.
	2:0	CurPstate: current P-state. Read,Error-on-write,Volatile. Reset: XXXb. This field provides the frequency component of the current non-boosted P-state of the core (regardless of the source of the P-state change, including Core::X86::Msr::PStateCtl[PstateCmd]. 0=P0, 1=P1, etc. The value of this field is updated when the COF transitions to a new value associated with a P-state.

#MSRC001_006[4...B] [P-state [7:0]] (Core::X86::Msr::PStateDef)
##Read-write. "Each of these registers specify the frequency and voltage associated with each of the core P-states. The CpuVid field in these registers is required to be programmed to the same value in all cores of a processor, but are allowed to be different between processors in a multi-processor system. All other fields in these registers are required to be programmed to the same value in each core of the coherent fabric."
###"_n0_aliasMSR; MSRC001_0064"
###"_n1_aliasMSR; MSRC001_0065"
###"_n2_aliasMSR; MSRC001_0066"
###"_n3_aliasMSR; MSRC001_0067"
###"_n4_aliasMSR; MSRC001_0068"
###"_n5_aliasMSR; MSRC001_0069"
###"_n6_aliasMSR; MSRC001_006A"
###"_n7_aliasMSR; MSRC001_006B"
	63	"PstateEn. Read-write. Reset: X. 0=The P-state specified by this MSR is not valid. 1=The P-state specified by this MSR is valid. The purpose of this register is to indicate if the rest of the P-state information in the register is valid after a reset; it controls no hardware."
	62:32	Reserved.
	31:30	IddDiv: current divisor. Read-write. Reset: XXb. See IddValue.
	29:22	"IddValue: current value. Read-write. Reset: XXXXXXXXb. After a reset, IddDiv and IddValue combine to specify the expected maximum current dissipation of a single core that is in the P-state corresponding to the MSR number. These values are intended to be used to create ACPI-defined _PSS objects. The values are expressed in amps; they are not intended to convey final product power levels; they may not match the power levels specified in the Power and Thermal Datasheets."
	21:14	CpuVid[7:0]: core VID. Read-write. Reset: XXXXXXXXb.
	13:8	"CpuDfsId: core divisor ID. Read-write. Reset: XXXXXXb. Specifies the core frequency divisor; see CpuFid. For values [1Ah:08h], 1/8th integer divide steps supported down to VCO/3.25 (Note, L3/L2 FIFO logic related to 4-cycle data heads-up requires core to be 1/3 of L3 frequency or higher). For values [30h:1Ch], 1/4th integer divide steps supported down to VCO/6 (DID[0] should zero if DID[5:0] > 1Ah). (Note, core and L3 frequencies below 400MHz are not supported by the architecture). Core supports DID up to 30h, but L3 must be 2Ch (VCO/5.5) or less."
ValidValues:
00h	Off
07h-01h	Reserved.
08h	VCO/1
09h	VCO/1.125
"1Ah- 0Ah"	VCO/<Value/8>
1Bh	Reserved.
1Ch	VCO/<Value/8>
1Dh	Reserved.
1Eh	VCO/<Value/8>
1Fh	Reserved.
20h	VCO/<Value/8>
21h	Reserved.
22h	VCO/<Value/8>
23h	Reserved.
24h	VCO/<Value/8>
25h	Reserved.
26h	VCO/<Value/8>
27h	Reserved.
29h Reserved.
2Ah VCO/<Value/8>
2Bh Reserved.
2Ch VCO/<Value/8>
3Fh-2Dh Reserved.
ValidValuesEnd
	7:0	CpuFid[7:0]: core frequency ID. Read-write. Reset: XXh. Specifies the core frequency multiplier. The core COF is a function of CpuFid and CpuDid, and defined by CoreCOF.
ValidValues:
0Fh-00h Reserved.
FFh-10h <Value>*25
ValidValuesEnd

#MSRC001_0073 [C-state Base Address] (Core::X86::Msr::CStateBaseAddr)
##Read-write. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_0073"
	63:16	Reserved.
	15:0	CstateAddr: C-state address. Read-write. Reset: 0000h. Specifies the IO addresses trapped by the core for C-state entry requests. A value of 0 in this field specifies that the core does not trap any IO addresses for C-state entry. Writing values greater than FFF8h into this field result in undefined behavior. All other values cause the core to trap IO addresses CstateAddr through CstateAddr + 7.

#MSRC001_0074 [CPU Watchdog Timer] (Core::X86::Msr::CpuWdtCfg)
##Read-write. Reset: 0000_0000_0000_0280h.
###"_ccd[7:0]_lthree0_core[7:0]; MSRC001_0074"
	63:10	Reserved.
	9:7	CpuWdTmrCfgSeverity. Read-write. Reset: 5h. Specifies the CPU Watch Dog Timer severity.
ValidValues:
4h-0h Reserved.
5h MCA_EXSC_ERROR_SEVERITY_FATAL
7h-6h Reserved.
ValidValuesEnd
	6:3	Reserved.
	2:1	CpuWdTmrTimebaseSel: CPU watchdog timer time base. Read-write. Reset: 0h. Specifies the time base for the timeout period specified in CpuWdtCountSel.
ValidValues:
0h 1.31 ms
1h 1.28 us
3h-2h Reserved.
ValidValuesEnd
	0	CpuWdTmrCfgEn: CPU watchdog timer enable. Read-write. Reset: 0. Init: BIOS,1. 1=The WDT is enabled.

#MSRC001_0111 [SMM Base Address] (Core::X86::Msr::SMM_BASE)
##Reset: 0000_0000_0003_0000h. This holds the base of the SMM memory region. The value of this register is stored in the save state on entry into SMM (see 2.1.14.1.5 [SMM Save State]) and it is restored on returning from SMM. The 16-bit CS (code segment) selector is loaded with SmmBase[19:4] on entering SMM. SmmBase[3:0] is required to be 0. The SMM base address can be
changed in two ways: The SMM base address, at offset FF00h in the SMM state save area, may be changed by the SMI handler. The RSM instruction updates SmmBase with the new value. •Normal WRMSR access to this register.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_0111"
	63:32	Reserved.
	31:0	SmmBase. Reset: 0003_0000h. Base address of the SMM memory region. AccessType: Core::X86::Msr::HWCR[SmmLock] ? Read-only : Read-write.

#MSRC001_0112 [SMM TSeg Base Address] (Core::X86::Msr::SMMAddr)
##Configurable. Reset: 0000_0000_0000_0000h. "See 2.1.14.1 [System Management Mode (SMM)] and 2.1.7.3.1 [Memory Access to the Physical Address Space]. See Core::X86::Msr::SMMMask for more information about the ASeg and TSeg address ranges. Each CPU access, directed at CPUAddr, is determined to be in the TSeg range if the following is true: CPUAddr[47:17] & TSegMask[47:17] == TSegBase[47:17] & TSegMask[47:17]. For example, if TSeg spans 256 KB and starts at the 1-MB address. The Core::X86::Msr::SMMAddr[TSegBase[47:17]] would be set to 0010_0000h and the Core::X86::Msr::SMMMask[TSegMask[47:17]] to FFFC_0000h (with zeros filling in for bits[16:0]). This results in a TSeg range from 0010_0000 to 0013_FFFFh."
###"_ccd[7:0]_lthree0_core[7:0]; MSRC001_0112"
	63:48	Reserved.
	47:17	"TSegBase[47:17]: TSeg address range base. Configurable. Reset: 0000_0000h. AccessType: (Core::X86::Msr::HWCR[SmmLock]) ? Read-only : Read-write."
	16:0	Reserved.

#MSRC001_0113 [SMM TSeg Mask] (Core::X86::Msr::SMMMask)
##Configurable. Reset: 0000_0000_0000_0000h. "See 2.1.14.1 [System Management Mode (SMM)]. The ASeg address range is located at a fixed address from A0000h–BFFFFh. The TSeg range is located at a variable base (specified by Core::X86::Msr::SMMAddr[TSegBase[47:17]]) with a variable size (specified by Core::X86::Msr::SMMMask[TSegMask[47:17]]). These ranges provide a safe location for SMM code and data that is not readily accessible by non-SMM applications. The SMI handler can be located in one of these two ranges, or it can be located outside these ranges. These ranges must never overlap each other. This register specifies how accesses to the ASeg and TSeg address ranges are controlled as follows: •If [A,T]Valid == 1, then: •If in SMM, then: •If [A, T]Close == 0, then the accesses are directed to DRAM with memory type as specified in [A, T]MTypeDram. •If [A, T]Close == 1, then instruction accesses are directed to DRAM with memory type as specified in [A, T]MTypeDram and data accesses are directed at MMIO space and with attributes based on [A, T]MTypeIoWc. •If not in SMM, then the accesses are directed at MMIO space with attributes based on [A,T]MTypeIoWc. •See 2.1.7.3.1.1 [Determining Memory Type]."
###"_ccd[7:0]_lthree0_core[7:0]; MSRC001_0113"
	47:17	TSegMask[47:17]: TSeg address range mask. Configurable. Reset: 0000_0000h. See Core::X86::Msr::SMMAddr. AccessType: (Core::X86::Msr::HWCR[SmmLock]) ? Read-only : Read-write.
	16:15	Reserved.
	14:12	TMTypeDram: TSeg address range memory type. Configurable. Reset: 0h. Specifies the memory type for SMM accesses to the TSeg range that are directed to DRAM. AccessType: (Core::X86::Msr::HWCR[SmmLock]) ? Read-only : Read-write.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	11	Reserved.
	10:8	AMTypeDram: ASeg Range Memory Type. Configurable. Reset: 0h. Specifies the memory type for SMM accesses to the ASeg range that are directed to DRAM. AccessType: (Core::X86::Msr::HWCR[SmmLock]) ? Read-only : Read-write.
ValidValues:
0h UC or uncacheable.
1h WC or write combining.
3h-2h Reserved.
4h WT or write through.
5h WP or write protect.
6h WB or write back.
7h Reserved.
ValidValuesEnd
	7:6	Reserved.
	5	TMTypeIoWc: non-SMM TSeg address range memory type. Configurable. Reset: 0. 0=UC (uncacheable). 1=WC (write combining). Specifies the attribute of TSeg accesses that are directed to MMIO space. AccessType: (Core::X86::Msr::HWCR[SmmLock]) ? Read-only : Read-write.
	4	AMTypeIoWc: non-SMM ASeg address range memory type. Configurable. Reset: 0. 0=UC (uncacheable). 1=WC (write combining). Specifies the attribute of ASeg accesses that are directed to MMIO space. AccessType: (Core::X86::Msr::HWCR[SmmLock]) ? Read-only : Read-write.
	3	TClose: send TSeg address range data accesses to MMIO. Configurable. Reset: 0. 1=When in SMM, direct data accesses in the TSeg address range to MMIO space. See AClose. AccessType: (Core::X86::Msr::HWCR[SmmLock]) ? Read-only : Read-write.
	2	AClose: send ASeg address range data accesses to MMIO. Configurable. Reset: 0. 1=When in SMM, direct data accesses in the ASeg address range to MMIO space. [A,T]Close allows the SMI handler to access the MMIO space located in the same address region as the [A,T]Seg. When the SMI handler is finished accessing the MMIO space, it must clear the bit. Failure to do so before resuming from SMM causes the CPU to erroneously read the save state from MMIO space. AccessType: (Core::X86::Msr::HWCR[SmmLock]) ? Read-only : Read-write.
	1	TValid: enable TSeg SMM address range. Configurable. Reset: 0. 1=The TSeg address range SMM enabled. AccessType: (Core::X86::Msr::HWCR[SmmLock]) ? Read-only : Read-write.
	0	AValid: enable ASeg SMM address range. Configurable. Reset: 0. 1=The ASeg address range SMM enabled. AccessType: (Core::X86::Msr::HWCR[SmmLock]) ? Read-only : Read-write.

#MSRC001_0114 [Virtual Machine Control] (Core::X86::Msr::VM_CR)
##Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_0114"
	63:5	Reserved.
	4	"SvmeDisable: SVME disable. Configurable. Reset: 0. 0=Core::X86::Msr::EFER[SVME] is Read-write. 1=Core::X86::Msr::EFER[SVME] is Read-only,Error-on-write-1. See Lock for the access type of this field. Attempting to set this field when (Core::X86::Msr::EFER[SVME] == 1) causes a #GP fault, regardless of the state of Lock. See the docAPM2 section titled ""Enabling SVM"" for software use of this field."
	3	"Lock: SVM lock. Read-only,Volatile. Reset: 0. 0=SvmeDisable is Read-write. 1=SvmeDisable is Read-only. See Core::X86::Msr::SvmLockKey[SvmLockKey] for the condition that causes hardware to clear this field."
	2	Reserved.
	1	"InterceptInit: intercept INIT. Read-write,Volatile. Reset: 0. 0=INIT delivered normally. 1=INIT translated into a SX interrupt. This bit controls how INIT is delivered in host mode. This bit is set by hardware when the SKINIT instruction is executed."
	0	Reserved.

#MSRC001_0115 [IGNNE] (Core::X86::Msr::IGNNE)
##Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_0115"
	63:1	Reserved.
	0	IGNNE: current IGNNE state. Read-write. Reset: 0. This bit controls the current state of the processor internal IGNNE signal.

#MSRC001_0116 [SMM Control] (Core::X86::Msr::SMM_CTL)
##Reset: 0000_0000_0000_0000h. "The bits in this register are processed in the order of: SmmEnter, SmiCycle, SmmDismiss, RsmCycle and SmmExit. However, only the following combination of bits may be set in a single write (all other combinations result in undefined behavior): •SmmEnter and SmiCycle. •SmmEnter and SmmDismiss. •SmmEnter, SmiCycle and SmmDismiss. •SmmExit and RsmCycle. Software is responsible for ensuring that SmmEnter and SmmExit operations are properly matched and are not nested."
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_0116"
	63:5	Reserved.
	4	RsmCycle: send RSM special cycle. Reset: 0. 1=Send a RSM special cycle. AccessType: Core::X86::Msr::HWCR[SmmLock] ? Error-on-read,Error-on-write : Write-only,Error-on-read.
	3	SmmExit: exit SMM. Reset: 0. 1=Exit SMM. AccessType: Core::X86::Msr::HWCR[SmmLock] ? Error-on-read,Error-on-write : Write-only,Error-on-read.
	2	SmiCycle: send SMI special cycle. Reset: 0. 1=Send a SMI special cycle. AccessType: Core::X86::Msr::HWCR[SmmLock] ? Error-on-read,Error-on-write : Write-only,Error-on-read.
	1	SmmEnter: enter SMM. Reset: 0. 1=Enter SMM. AccessType: Core::X86::Msr::HWCR[SmmLock] ? Error-on-read,Error-on-write : Write-only,Error-on-read.
	0	SmmDismiss: clear SMI. Reset: 0. 1=Clear the SMI pending flag.

#MSRC001_0117 [Virtual Machine Host Save Physical Address] (Core::X86::Msr::VM_HSAVE_PA)
##Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_0117"
	63:48	Reserved.
	47:12	"VM_HSAVE_PA: physical address of host save area. Read-write. Reset: 0_0000_0000h. This register contains the physical address of a 4-KB region where VMRUN saves host state and where vm-exit restores host state from. Writing this register causes a #GP if (FFFF_FFFF_Fh >= VM_HSAVE_PA >= FFFD_0000_0h) or if either the TSEG or ASEG regions overlap with the range defined by this register."
	11:0	Reserved.

#MSRC001_0118 [SVM Lock Key] (Core::X86::Msr::SvmLockKey)
##Read-write. Reset: Fixed,0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_0118"
	63:0	"SvmLockKey: SVM lock key. Read-write. Reset: Fixed,0000_0000_0000_0000h. Writes to this register when (Core::X86::Msr::VM_CR[Lock] == 0) modify SvmLockKey. If ((Core::X86::Msr::VM_CR[Lock] == 1) && (SvmLockKey!=0) && (The write value == The value stored in SvmLockKey)) for a write to this register then hardware updates Core::X86::Msr::VM_CR[Lock] = 0."

#MSRC001_011A [Local SMI Status] (Core::X86::Msr::LocalSmiStatus)
##Read-write. Reset: 0000_0000_0000_0000h. "This register returns the same information that is returned in Core::X86::Smm::LocalSmiStatus portion of the SMM save state. The information in this register is only updated when Core::X86::Msr::SMM_CTL[SmmDismiss] is set by software."
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_011A"
	63:32	Reserved.
	31:0	LocalSmiStatus. Read-write. Reset: 0000_0000h. See Core::X86::Smm::LocalSmiStatus.

#MSRC001_011B [AVIC Doorbell] (Core::X86::Msr::AvicDoorbell)
##Write-only,Error-on-read. Reset: 0000_0000_0000_0000h. "The ApicId is a physical APIC ID; not valid for logical APIC ID. Enable: (Core::X86::Cpuid::SvmRevFeatIdEdx[AVIC] == 1)."
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_011B"
	63:32	Reserved.
	31:0	ApicId: APIC ID [31:0]. Write-only,Error-on-read. Reset: 0000_0000h. The value written must be a valid physical APID_ID.

#MSRC001_011E [VM Page Flush] (Core::X86::Msr::VMPAGE_FLUSH)
##Write-only,Error-on-read.	Writes to this MSR causes 4 KBs of encrypted, guest-tagged data to be flushed from caches if present. This MSR is Write-only, and can only be written from ASID == 0 code and only if Core::X86::Msr::SYS_CFG[SMEE] == 1.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_011E"
	63:12	"GuestPhysicalAddr. Write-only,Error-on-read. Reset: X_XXXX_XXXX_XXXXh. Guest physical address of page to flush."
	11:0	ASID. Write-only,Error-on-read. Reset: XXXh. ASID to use for flush. This value must be within the legal ASID range indicated by CPUID_Fn8000001F_ECX (Core::X86::Cpuid::SecureEncryptionEcx), and cannot be zero.

#MSRC001_0130 [Guest Host Communication Block] (Core::X86::Msr::GHCB)
##Read-write. Reset: 0000_0000_0000_0000h. If Core::X86::Msr::GHCB is accessed in hypervisor mode, #GP is generated.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_0130"
	63:0	GHCBPA. Read-write. Reset: 0000_0000_0000_0000h. Guest physical address of GHCB.

#MSRC001_0131 [SEV Status] (Core::X86::Msr::SEV_Status)
##Read,Error-on-write. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_0131"
	63:10	Reserved.
	9	SNPBTBIsolation. Read,Error-on-write. Reset: 0. 1=BTB predictor isolation is enabled for this guest.
	8	Reserved.
	7	DebugSwapSupport. Read,Error-on-write. Reset: 0. 1=Extra debug registers are swapped for this guest.
	6	"AlternateInjection. Read,Error-on-write. Reset: 0. 1=Alternate Injection feature is enabled for this guest (encrypted VMSA fields used to provide injection information)."
	5	"RestrictInjection. Read,Error-on-write. Reset: 0. 1=Restrict Injection feature is enabled for this guest (only #HV can be injected)."
	4	ReflectVC. Read,Error-on-write. Reset: 0. 1=#VC exceptions are turned into an AE VMEXIT for this guest.
	3	VirtualTOM. Read,Error-on-write. Reset: 0. 1=Virtual TOM feature is enabled for this guest.
	2	SNPActive. Read,Error-on-write. Reset: 0. 1=Secure Nested Paging is active for this guest.
	1	"SevEsEnabled. Read,Error-on-write. Reset: 0. 1=The guest was launched with the Sev-ES feature enabled in VMCB offset 90h."
	0	SevEnabled. Read,Error-on-write. Reset: 0. 1=The guest was launched with SEV feature enabled in VMCB offset 90h.

#MSRC001_0132 [RMP Base] (Core::X86::Msr::LS_RMP_BASE)
##Secure Nested Paging Reverse Map Table Base.
###"_ccd[7:0]_lthree0_core[7:0]; MSRC001_0132"
	63:52	Reserved.
	51:13	RMP_BASE. Reset: 00_0000_0000h. Secure Nested Paging Reverse Map Table Base. AccessType: Core::X86::Msr::SYS_CFG[SecureNestedPagingEn] ? Read,Error-on-write : Read-write.
	12:0	Reserved.

#MSRC001_0133 [RMP End] (Core::X86::Msr::LS_RMP_END)
##Secure Nested Paging Reverse Map Table Limit.
###"_ccd[7:0]_lthree0_core[7:0]; MSRC001_0133"
	63:52	Reserved.
	51:13	RMP_END. Reset: 00_0000_0000h. Secure Nested Paging Reverse Map Table Limit. AccessType: Core::X86::Msr::SYS_CFG[SecureNestedPagingEn] ? Read,Error-on-write : Read-write.
	12:0	Reserved.

#MSRC001_0140 [OS Visible Work-around Length] (Core::X86::Msr::OSVW_ID_Length)
##Read-write. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_0140"
	63:16	Reserved.
	15:0	OSVWIdLength: OS visible work-around ID length. Read-write. Reset: 0000h. See the Revision Guide for the definition of this field; see 1.2 [Reference Documents].

#MSRC001_0141 [OS Visible Work-around Status] (Core::X86::Msr::OSVW_Status)
##Read-write. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_0141"
	63:0	OsvwStatusBits: OS visible work-around status bits. Read-write. Reset: 0000_0000_0000_0000h. See the Revision Guide for the definition of this field; see 1.2 [Reference Documents].

#MSRC001_0200 [Performance Event Select 0] (Core::X86::Msr::PERF_CTL0)
##Read-write. Reset: 0000_0000_0000_0000h. See 2.1.17 [Performance Monitor Counters]. Core::X86::Msr::PERF_LEGACY_CTL0 is an alias of this register.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_0200"
	63:42	Reserved.
	41:40	HostGuestOnly: count only host/guest events. Read-write. Reset: 0h.
ValidValues:
0h Count all events, irrespective of guest/host.
1h Count guest events if [SVME] == 1.
2h Count host events if [SVME] == 1.
3h Count all guest and host events if [SVME] == 1.
ValidValuesEnd
	39:36	Reserved.
	35:32	EventSelect[11:8]. Read-write. Reset: 0h. Performance event select[11:8].
	31:24	CntMask: counter mask. Read-write. Reset: 00h. Controls the number of events counted per clock cycle.
ValidValues:
00h The corresponding PERF_CTR[5:0] register increments by the number of events occurring in a clock cycle. See 2.1.17.3 [Large Increment per Cycle Events] for events that can increment greater than 15 per cycle.
7Fh-01h When Inv == 0, the corresponding PERF_CTR[5:0] register increments by 1, if the number of events occurring in a clock cycle is greater than or equal to the CntMask value. When Inv == 1, the corresponding PERF_CTR[5:0] register increments by 1, if the number of events occurring in a clock cycle is less than CntMask value.
FFh-80h Reserved.
ValidValuesEnd
	23	Inv: invert counter mask. Read-write. Reset: 0. See CntMask.
	22	En: enable performance counter. Read-write. Reset: 0. 1=Performance event counter is enabled.
	21	Reserved.
	20	Int: enable APIC interrupt. Read-write. Reset: 0. 1=APIC performance counter LVT interrupt is enabled to generate an interrupt via Core::X86::Apic::PerformanceCounterLvtEntry when the performance counter overflows.
	19	Reserved.
	18	Edge: edge detect. Read-write. Reset: 0. 0=Level detect. 1=Zero-to-one Edge detect. The edge count mode increments the counter when a transition happens on the monitored event. If the event selected is changed without disabling the counter, an extra edge is falsely detected when the first event is a static 0 and the second event is a static one. To avoid this false edge detection, disable the counter when changing the event and then enable the counter with a second MSR write.
	17:16	OsUserMode: OS and user mode. Read-write. Reset: 0h.
ValidValues:
0h Count no events.
1h Count user events (CPL>0).
2h Count OS events (CPL=0).
3h Count all events, irrespective of the CPL.
ValidValuesEnd
	15:8	UnitMask: event qualification. Read-write. Reset: 00h. Each UnitMask bit further specifies or qualifies the event specified by EventSelect. All events selected by UnitMask are simultaneously monitored. Unless otherwise stated, the UnitMask values shown may be combined (logically ORed) to select any desired combination of the sub-events for a given event. In some cases, certain combinations can result in misleading counts, or the UnitMask value is an ordinal rather than a bit mask. These situations are described where applicable, or should be obvious from the event descriptions. For events where no UnitMask table is shown, the UnitMask is Unused.
	7:0	EventSelect[7:0]: event select. Read-write. Reset: 00h. EventSelect[11:0] = {EventSelect[11:8], EventSelect[7:0]}. EventSelect specifies the event or event duration in a processor unit to be counted by the corresponding PERF_CTR[5:0] register. The events are specified in 2.1.17.4 [Core Performance Monitor Counters]. Some events are Reserved; when a Reserved event is selected, the results are undefined.

#MSRC001_020[1...B] [Performance Event Counter [5:0]] (Core::X86::Msr::PERF_CTR)
##Note: When counting events that capable of counting greater than 15 events per cycle (MergeEvent) the even and the corresponding odd PERF_CTR must be paired to appear as a single 64-bit counter. See 2.1.17.3 [Large Increment per Cycle Events]. See Core::X86::Msr::PERF_CTL0..5. Core::X86::Msr::PERF_LEGACY_CTR is an alias of MSRC001_020[7,5,3,1]. Also can be Read via x86 instructions RDPMC ECX = [05:00].
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n0; MSRC001_0201"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n1; MSRC001_0203"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n2; MSRC001_0205"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n3; MSRC001_0207"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n4; MSRC001_0209"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n5; MSRC001_020B"
	63:48	Reserved.
	47:0	CTR. Read-write,Volatile. Reset: 0000_0000_0000h. Performance counter value.

#MSRC001_0202 [Performance Event Select 1] (Core::X86::Msr::PERF_CTL1)
##Read-write. Reset: 0000_0000_0000_0000h. See 2.1.17 [Performance Monitor Counters]. Core::X86::Msr::PERF_LEGACY_CTL1 is an alias of this register.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_0202"
	63:42	Reserved.
	41:40	HostGuestOnly: count only host/guest events. Read-write. Reset: 0h.
ValidValues:
0h Count all events, irrespective of guest/host.
1h Count guest events if [SVME] == 1.
2h Count host events if [SVME] == 1.
3h Count all guest and host events if [SVME] == 1.
ValidValuesEnd
	39:36	Reserved.
	35:32	EventSelect[11:8]. Read-write. Reset: 0h. Performance event select[11:8].
	31:24	CntMask: counter mask. Read-write. Reset: 00h. Controls the number of events counted per clock cycle.
ValidValues:
00h	The corresponding PERF_CTR[5:0] register increments by the number of events occurring in a clock cycle. See 2.1.17.3 [Large Increment per Cycle Events] for events that can increment greater than 15 per cycle.
7Fh-01h	When Inv == 0, the corresponding PERF_CTR[5:0] register increments by 1, if the number of events occurring in a clock cycle is greater than or equal to the CntMask value. When Inv == 1, the corresponding PERF_CTR[5:0] register increments by 1, if the number of events occurring in a clock cycle is less than CntMask value.
FFh-80h	Reserved.
ValidValuesEnd
	23	Inv: invert counter mask. Read-write. Reset: 0. See CntMask.
	22	En: enable performance counter. Read-write. Reset: 0. 1=Performance event counter is enabled.
	21	Reserved.
	20	Int: enable APIC interrupt. Read-write. Reset: 0. 1=APIC performance counter LVT interrupt is enabled to generate an interrupt via Core::X86::Apic::PerformanceCounterLvtEntry when the performance counter overflows.
	19	Reserved.
	18	Edge: edge detect. Read-write. Reset: 0. 0=Level detect. 1=Zero-to-one Edge detect. The edge count mode increments the counter when a transition happens on the monitored event. If the event selected is changed without disabling the counter, an extra edge is falsely detected when the first event is a static 0 and the second event is a static one. To avoid this false edge detection, disable the counter when changing the event and then enable the counter with a second MSR write.
	17:16	OsUserMode: OS and user mode. Read-write. Reset: 0h.
ValidValues:
0h Count no events.
1h Count user events (CPL>0).
2h Count OS events (CPL=0).
3h Count all events, irrespective of the CPL.
ValidValuesEnd
	15:8	UnitMask: event qualification. Read-write. Reset: 00h. Each UnitMask bit further specifies or qualifies the event specified by EventSelect. All events selected by UnitMask are simultaneously monitored. Unless otherwise stated, the UnitMask values shown may be combined (logically ORed) to select any desired combination of the sub-events for a given event. In some cases, certain combinations can result in misleading counts, or the UnitMask value is an ordinal rather than a bit mask. These situations are described where applicable, or should be obvious from the event descriptions. For events where no UnitMask table is shown, the UnitMask is Unused.
	7:0	EventSelect[7:0]: event select. Read-write. Reset: 00h. EventSelect[11:0] = {EventSelect[11:8], EventSelect[7:0]}. EventSelect specifies the event or event duration in a processor unit to be counted by the corresponding PERF_CTR[5:0] register. The events are specified in 2.1.17.4 [Core Performance Monitor Counters]. Some events are Reserved; when a Reserved event is selected, the results are undefined.

#MSRC001_0204 [Performance Event Select 2] (Core::X86::Msr::PERF_CTL2)
##Read-write. Reset: 0000_0000_0000_0000h. See 2.1.17 [Performance Monitor Counters]. Core::X86::Msr::PERF_LEGACY_CTL2 is an alias of this register.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_0204"
	63:42	Reserved.
	41:40	HostGuestOnly: count only host/guest events. Read-write. Reset: 0h.
ValidValues:
0h Count all events, irrespective of guest/host.
1h Count guest events if [SVME] == 1.
2h Count host events if [SVME] == 1.
3h Count all guest and host events if [SVME] == 1.
ValidValuesEnd
	39:36	Reserved.
	35:32	EventSelect[11:8]. Read-write. Reset: 0h. Performance event select[11:8].
	31:24	CntMask: counter mask. Read-write. Reset: 00h. Controls the number of events counted per clock cycle.
ValidValues:
00h	The corresponding PERF_CTR[5:0] register increments by the number of events occurring in a clock cycle. See 2.1.17.3 [Large Increment per Cycle Events] for events that can increment greater than 15 per cycle.
7Fh-01h	When Inv == 0, the corresponding PERF_CTR[5:0] register increments by 1, if the number of events occurring in a clock cycle is greater than or equal to the CntMask value. When Inv == 1, the corresponding PERF_CTR[5:0] register increments by 1, if the number of events occurring in a clock cycle is less than CntMask value.
FFh-80h	Reserved.
ValidValuesEnd
	23	Inv: invert counter mask. Read-write. Reset: 0. See CntMask.
	22	En: enable performance counter. Read-write. Reset: 0. 1=Performance event counter is enabled.
	21	Reserved.
	20	Int: enable APIC interrupt. Read-write. Reset: 0. 1=APIC performance counter LVT interrupt is enabled to generate an interrupt via Core::X86::Apic::PerformanceCounterLvtEntry when the performance counter overflows.
	19	Reserved.
	18	Edge: edge detect. Read-write. Reset: 0. 0=Level detect. 1=Zero-to-one Edge detect. The edge count mode increments the counter when a transition happens on the monitored event. If the event selected is changed without disabling the counter, an extra edge is falsely detected when the first event is a static 0 and the second event is a static one. To avoid this false edge detection, disable the counter when changing the event and then enable the counter with a second MSR write.
	17:16	OsUserMode: OS and user mode. Read-write. Reset: 0h.
ValidValues:
0h	Count no events.
1h	Count user events (CPL>0).
2h	Count OS events (CPL=0).
3h	Count all events, irrespective of the CPL.
ValidValuesEnd
	15:8	UnitMask: event qualification. Read-write. Reset: 00h. Each UnitMask bit further specifies or qualifies the event specified by EventSelect. All events selected by UnitMask are simultaneously monitored. Unless otherwise stated, the UnitMask values shown may be combined (logically ORed) to select any desired combination of the sub-events for a given event. In some cases, certain combinations can result in misleading counts, or the UnitMask value is an ordinal rather than a bit mask. These situations are described where applicable, or should be obvious from the event descriptions. For events where no UnitMask table is shown, the UnitMask is Unused.
	7:0	EventSelect[7:0]: event select. Read-write. Reset: 00h. EventSelect[11:0] = {EventSelect[11:8],EventSelect[7:0]}. EventSelect specifies the event or event duration in a processor unit to be counted by the corresponding PERF_CTR[5:0] register. The events are specified in 2.1.17.4 [Core Performance Monitor Counters]. Some events are Reserved; when a Reserved event is selected, the results are undefined.

#MSRC001_0206 [Performance Event Select 3] (Core::X86::Msr::PERF_CTL3)
##Read-write. Reset: 0000_0000_0000_0000h. See 2.1.17 [Performance Monitor Counters]. Core::X86::Msr::PERF_LEGACY_CTL3 is an alias of this register.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_0206"
	63:42	Reserved.
	41:40	HostGuestOnly: count only host/guest events. Read-write. Reset: 0h.
ValidValues:
0h Count all events, irrespective of guest/host.
1h Count guest events if [SVME] == 1.
2h Count host events if [SVME] == 1.
3h Count all guest and host events if [SVME] == 1.
ValidValuesEnd
	39:36	Reserved.
	35:32	EventSelect[11:8]. Read-write. Reset: 0h. Performance event select[11:8].
	31:24	CntMask: counter mask. Read-write. Reset: 00h. Controls the number of events counted per clock cycle.
ValidValues:
00h	The corresponding PERF_CTR[5:0] register increments by the number of events occurring in a clock cycle. See 2.1.17.3 [Large Increment per Cycle Events] for events that can increment greater than 15 per cycle.
7Fh-01h	When Inv == 0, the corresponding PERF_CTR[5:0] register increments by 1, if the number of events occurring in a clock cycle is greater than or equal to the CntMask value. When Inv == 1, the corresponding PERF_CTR[5:0] register increments by 1, if the number of events occurring in a clock cycle is less than CntMask value.
FFh-80h Reserved.
ValidValuesEnd
	23	Inv: invert counter mask. Read-write. Reset: 0. See CntMask.
	22	En: enable performance counter. Read-write. Reset: 0. 1=Performance event counter is enabled.
	21	Reserved.
	20	Int: enable APIC interrupt. Read-write. Reset: 0. 1=APIC performance counter LVT interrupt is enabled to generate an interrupt via Core::X86::Apic::PerformanceCounterLvtEntry when the performance counter overflows.
	19	Reserved.
	18	Edge: edge detect. Read-write. Reset: 0. 0=Level detect. 1=Zero-to-one Edge detect. The edge count mode increments the counter when a transition happens on the monitored event. If the event selected is changed without disabling the counter, an extra edge is falsely detected when the first event is a static 0 and the second event is a static one. To avoid this false edge detection, disable the counter when changing the event and then enable the counter with a second MSR write.
	17:16	OsUserMode: OS and user mode. Read-write. Reset: 0h.
ValidValues:
0h Count no events.
1h Count user events (CPL>0).
2h Count OS events (CPL=0).
3h Count all events, irrespective of the CPL.
ValidValuesEnd
	15:8	UnitMask: event qualification. Read-write. Reset: 00h. Each UnitMask bit further specifies or qualifies the event specified by EventSelect. All events selected by UnitMask are simultaneously monitored. Unless otherwise stated, the UnitMask values shown may be combined (logically ORed) to select any desired combination of the sub-events for a given event. In some cases, certain combinations can result in misleading counts, or the UnitMask value is an ordinal rather than a bit mask. These situations are described where applicable, or should be obvious from the event descriptions. For events where no UnitMask table is shown, the UnitMask is Unused.
	7:0	EventSelect[7:0]: event select. Read-write. Reset: 00h. EventSelect[11:0] = {EventSelect[11:8], EventSelect[7:0]}. EventSelect specifies the event or event duration in a processor unit to be counted by the corresponding PERF_CTR[5:0] register. The events are specified in 2.1.17.4 [Core Performance Monitor Counters]. Some events are Reserved; when a Reserved event is selected, the results are undefined.

#MSRC001_0208 [Performance Event Select 4] (Core::X86::Msr::PERF_CTL4)
##Read-write. Reset: 0000_0000_0000_0000h. See 2.1.17 [Performance Monitor Counters].
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_0208"
	63:42	Reserved.
	41:40	HostGuestOnly: count only host/guest events. Read-write. Reset: 0h.
ValidValues:
0h Count all events, irrespective of guest/host.
1h Count guest events if [SVME] == 1.
2h Count host events if [SVME] == 1.
3h Count all guest and host events if [SVME] == 1.
ValidValuesEnd
	39:36	Reserved.
	35:32	EventSelect[11:8]. Read-write. Reset: 0h. Performance event select[11:8].
	31:24	CntMask: counter mask. Read-write. Reset: 00h. Controls the number of events counted per clock cycle.
ValidValues:
00h	The corresponding PERF_CTR[5:0] register increments by the number of events occurring in a clock cycle. See 2.1.17.3 [Large Increment per Cycle Events] for events that can increment greater than 15 per cycle.
7Fh-01h	When Inv == 0, the corresponding PERF_CTR[5:0] register increments by 1, if the number of events occurring in a clock cycle is greater than or equal to the CntMask value. When Inv == 1, the corresponding PERF_CTR[5:0] register increments by 1, if the number of events occurring in a clock cycle is less than CntMask value.
FFh-80h	Reserved.
ValidValuesEnd
	23	Inv: invert counter mask. Read-write. Reset: 0. See CntMask.
	22	En: enable performance counter. Read-write. Reset: 0. 1=Performance event counter is enabled.
	21	Reserved.
	20	Int: enable APIC interrupt. Read-write. Reset: 0. 1=APIC performance counter LVT interrupt is enabled to generate an interrupt via Core::X86::Apic::PerformanceCounterLvtEntry when the performance counter overflows.
	19	Reserved.
	18	Edge: edge detect. Read-write. Reset: 0. 0=Level detect. 1=Zero-to-one Edge detect. The edge count mode increments the counter when a transition happens on the monitored event. If the event selected is changed without disabling the counter, an extra edge is falsely detected when the first event is a static 0 and the second event is a static one. To avoid this false edge detection, disable the counter when changing the event and then enable the counter with a second MSR write.
	17:16	OsUserMode: OS and user mode. Read-write. Reset: 0h.
ValidValues:
0h Count no events.
1h Count user events (CPL>0).
2h Count OS events (CPL=0).
3h Count all events, irrespective of the CPL.
ValidValuesEnd
	15:8	UnitMask: event qualification. Read-write. Reset: 00h. Each UnitMask bit further specifies or qualifies the event specified by EventSelect. All events selected by UnitMask are simultaneously monitored. Unless otherwise stated, the UnitMask values shown may be combined (logically ORed) to select any desired combination of the sub-events for a given event. In some cases, certain combinations can result in misleading counts, or the UnitMask value is an ordinal rather than a bit mask. These situations are described where applicable, or should be obvious from the event descriptions. For events where no UnitMask table is shown, the UnitMask is Unused.
	7:0	EventSelect[7:0]: event select. Read-write. Reset: 00h. EventSelect[11:0] = {EventSelect[11:8], EventSelect[7:0]}. EventSelect specifies the event or event duration in a processor unit to be counted by the corresponding PERF_CTR[5:0] register. The events are specified in 2.1.17.4 [Core Performance Monitor Counters]. Some events are Reserved; when a Reserved event is selected, the results are undefined.

#MSRC001_020A [Performance Event Select 5] (Core::X86::Msr::PERF_CTL5)
##Read-write. Reset: 0000_0000_0000_0000h. See 2.1.17 [Performance Monitor Counters].
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_020A"
	63:42	Reserved.
	41:40	HostGuestOnly: count only host/guest events. Read-write. Reset: 0h.
ValidValues:
0h Count all events, irrespective of guest/host.
1h Count guest events if [SVME] == 1.
2h Count host events if [SVME] == 1.
3h Count all guest and host events if [SVME] == 1.
ValidValuesEnd
	39:36	Reserved.
	35:32	EventSelect[11:8]. Read-write. Reset: 0h. Performance event select[11:8].
	31:24	CntMask: counter mask. Read-write. Reset: 00h. Controls the number of events counted per clock cycle.
ValidValues:
00h	The corresponding PERF_CTR[5:0] register increments by the number of events occurring in a clock cycle. See 2.1.17.3 [Large Increment per Cycle Events] for events that can increment greater than 15 per cycle.
7Fh-01h	When Inv == 0, the corresponding PERF_CTR[5:0] register increments by 1, if the number of events occurring in a clock cycle is greater than or equal to the CntMask value. When Inv == 1, the corresponding PERF_CTR[5:0] register increments by 1, if the number of events occurring in a clock cycle is less than CntMask value.
FFh-80h Reserved.
ValidValuesEnd
	23	Inv: invert counter mask. Read-write. Reset: 0. See CntMask.
	22	En: enable performance counter. Read-write. Reset: 0. 1=Performance event counter is enabled.
	21	Reserved.
	20	Int: enable APIC interrupt. Read-write. Reset: 0. 1=APIC performance counter LVT interrupt is enabled to generate an interrupt via Core::X86::Apic::PerformanceCounterLvtEntry when the performance counter overflows.
	19	Reserved.
	18	Edge: edge detect. Read-write. Reset: 0. 0=Level detect. 1=Zero-to-one Edge detect. The edge count mode increments the counter when a transition happens on the monitored event. If the event selected is changed without disabling the counter, an extra edge is falsely detected when the first event is a static 0 and the second event is a static one. To avoid this false edge detection, disable the counter when changing the event and then enable the counter with a second MSR write.
	17:16	OsUserMode: OS and user mode. Read-write. Reset: 0h.
ValidValues:
0h Count no events.
1h Count user events (CPL>0).
2h Count OS events (CPL=0).
3h Count all events, irrespective of the CPL.
ValidValuesEnd
	15:8	UnitMask: event qualification. Read-write. Reset: 00h. Each UnitMask bit further specifies or qualifies the event specified by EventSelect. All events selected by UnitMask are simultaneously monitored. Unless otherwise stated, the UnitMask values shown may be combined (logically ORed) to select any desired combination of the sub-events for a given event. In some cases, certain combinations can result in misleading counts, or the UnitMask value is an ordinal rather than a bit mask. These situations are described where applicable, or should be obvious from the event descriptions. For events where no UnitMask table is shown, the UnitMask is Unused.
	7:0	EventSelect[7:0]: event select. Read-write. Reset: 00h. EventSelect[11:0] = {EventSelect[11:8], EventSelect[7:0]}. EventSelect specifies the event or event duration in a processor unit to be counted by the corresponding PERF_CTR[5:0] register. The events are specified in 2.1.17.4 [Core Performance Monitor Counters]. Some events are Reserved; when a Reserved event is selected, the results are undefined.

#MSRC001_023[0...A] [L3 Performance Event Select [5:0]] (Core::X86::Msr::ChL3PmcCfg)
##Read-write. Reset: 0000_0000_0000_0000h. See 2.1.17.5 [L3 Cache Performance Monitor Counters]
###"_ccd[7:0]_lthree0_n0; MSRC001_0230"
###"_ccd[7:0]_lthree0_n1; MSRC001_0232"
###"_ccd[7:0]_lthree0_n2; MSRC001_0234"
###"_ccd[7:0]_lthree0_n3; MSRC001_0236"
###"_ccd[7:0]_lthree0_n4; MSRC001_0238"
###"_ccd[7:0]_lthree0_n5; MSRC001_023A"
	63:60	Reserved.
	59:56	ThreadMask. Read-write. Reset: 0h. Controls which of the 2 threads in the selected core are being counted. In non-SMT mode, thread[0] must be selected. One or more threads must be selected unless otherwise specified by the specific L3PMC event.
ValidValues:
"[0] Thread[0]."
"[1] Thread[1]."
"[3:2] Reserved."
ValidValuesEnd
	55:51	Reserved.
	50:48	SliceId. Read-write. Reset: 0h. Controls the L3 slice for which events are counted. Unless otherwise noted by the specific L3PMC event, use Core::X86::Msr::ChL3PmcCfg[SliceId] to select an individual slice or Core::X86::Msr::ChL3PmcCfg[EnAllSlices] to select all slices.
ValidValues:
7h-0h <Value> Slice.
ValidValuesEnd
	47	EnAllCores. Read-write. Reset: 0. 1=Enable counting L3 events for all cores simultaneously.
	46	EnAllSlices. Read-write. Reset: 0. 1=Enable counting L3 events for all 8 L3 slices simultaneously.
	45	Reserved.
	44:42	CoreId. Read-write. Reset: 0h. Controls core for which events are to be counted. See Core::X86::Msr::ChL3PmcCfg[EnAllCores] to count all cores simultaneously.
ValidValues:
7h-0h <Value> CoreId.
ValidValuesEnd
	41:23	Reserved.
	22	Enable: Enable L3 performance counter. Read-write. Reset: 0. 1=Enable.
	21:16	Reserved.
	15:8	UnitMask: event qualification. Read-write. Reset: 00h. Each UnitMask bit further specifies or qualifies the event specified by EventSelect. All events selected by UnitMask are simultaneously monitored. Unless otherwise stated, the UnitMask values shown may be combined (logically ORed) to select any desired combination of the sub-events for a given event. In some cases, certain combinations can result in misleading counts, or the UnitMask value is an ordinal rather than a bit mask. These situations are described where applicable, or should be obvious from the event descriptions. For events where no UnitMask table is shown, the UnitMask is Unused. When selecting an event for which not all UnitMask bits are defined, the undefined UnitMask bits should be set to zero.
	7:0	EventSel. Read-write. Reset: 00h. L3 Event select.

#MSRC001_023[1...B] [L3 Performance Event Counter [5:0]] (Core::X86::Msr::ChL3Pmc)
##Reset: 0000_0000_0000_0000h. Also can be read via x86 instructions RDPMC ECX=[0F:0A].
###"_ccd[7:0]_lthree0_n0; MSRC001_0231"
###"_ccd[7:0]_lthree0_n1; MSRC001_0233"
###"_ccd[7:0]_lthree0_n2; MSRC001_0235"
###"_ccd[7:0]_lthree0_n3; MSRC001_0237"
###"_ccd[7:0]_lthree0_n4; MSRC001_0239"
###"_ccd[7:0]_lthree0_n5; MSRC001_023B"
	63:49	Reserved.
	48	Overflow. Read-write. Reset: 0. Count overflow bit.
	47:32	CountHi. Read-write,Volatile. Reset: 0000h. Bits[47:32] of the count.
	31:0	CountLo. Read-write,Volatile. Reset: 0000_0000h. Bits[31:0] of the count.

#MSRC001_024[0...6] [Data Fabric Performance Event Select [3:0]] (Core::X86::Msr::DF_PERF_CTL)
##Read-write. Reset: 0000_0000_0000_0000h. "See 2.1.17 [Performance Monitor Counters]. The DF Performance Monitors are shared by all cores/threads in the node. See 2.1.11 [Register Sharing]."
###"_n0; MSRC001_0240"
###"_n1; MSRC001_0242"
###"_n2; MSRC001_0244"
###"_n3; MSRC001_0246"
	63:61	Reserved.
	60:59	EventSelect[13:12]. Read-write. Reset: 0h. Performance event select [13:12].
	58:36	Reserved.
	35:32	EventSelect[11:8]: performance event select. Read-write. Reset: 0h. Performance event select [11:0].
	31:23	Reserved.
	22	En: enable performance counter. Read-write. Reset: 0. 1=Performance event counter is enabled.
	21:16	Reserved.
	15:8	UnitMask: event qualification. Read-write. Reset: 00h. Each UnitMask bit further specifies or qualifies the event specified by EventSelect. All events selected by UnitMask are simultaneously monitored.
	7:0	EventSelect[7:0]: event select. Read-write. Reset: 00h. This field, along with EventSelect[13:12] and EventSelect[11:8] above, combine to form the 14-bit event select field, EventSelect[13:0]. EventSelect specifies the event or event duration in a processor unit to be counted by the corresponding DF_PERF_CTR[3:0] register. Some events are reserved; when a reserved event is selected, the results are undefined.

#MSRC001_024[1...7] [Data Fabric Performance Event Counter [3:0]] (Core::X86::Msr::DF_PERF_CTR)
##See Core::X86::Msr::DF_PERF_CTL. Also can be read via x86 instructions RDPMC ECX = [09:06]. The DF Performance Monitors are shared by all cores/threads in the node. See 2.1.11 [Register Sharing].
###"_n0; MSRC001_0241"
###"_n1; MSRC001_0243"
###"_n2; MSRC001_0245"
###"_n3; MSRC001_0247"
	63:48	Reserved.
	47:0	CTR[47:0]: performance counter value[47:0]. Read-write,Volatile. Reset: 0000_0000_0000h. The current value of the event counter.

#MSRC001_0299 [RAPL Power Unit] (Core::X86::Msr::RAPL_PWR_UNIT)
##Read-only,Volatile. Reset: 0000_0000_000A_1003h.
###"_ccd[7:0]_lthree0; MSRC001_0299"
	63:20	Reserved.
	19:16	TU: Time Units in seconds. Read-only,Volatile. Reset: Ah. Time information (in Seconds) is based on the multiplier, 1/ 2^TU; where TU is an unsigned integer. Default value is 1010b, indicating time unit is in 976 microseconds increment.
ValidValues:
Fh-0h 1/2^<Value> Seconds
ValidValuesEnd
	15:13	Reserved.
	12:8	ESU: Energy Status Units. Read-only,Volatile. Reset: 10h. Energy information (in Joules) is based on the multiplier, 1/2^ESU; where ESU is an unsigned integer. Default value is 10000b, indicating energy status unit is in 15.3 micro-Joules increment.
ValidValues:
1Fh-00h 1/2^<Value> Joules
ValidValuesEnd
	7:4	Reserved.
	3:0	PU: Power Units. Read-only,Volatile. Reset: 3h. Power information (in Watts) is based on the multiplier, 1/2^PU; where PU is an unsigned integer. Default value is 0011b, indicating power unit is in 1/8 Watts increment.
ValidValues:
Fh-0h 1/2^<Value> Watts
ValidValuesEnd

#MSRC001_029A [Core Energy Status] (Core::X86::Msr::CORE_ENERGY_STAT)
##Read-only,Volatile. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]; MSRC001_029A"
	63:32	Reserved.
	31:0	TotalEnergyConsumed. Read-only,Volatile. Reset: 0000_0000h.

#MSRC001_029B [Package Energy Status] (Core::X86::Msr::PKG_ENERGY_STAT)
##Read-only,Volatile. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]; MSRC001_029B"
	63:32	Reserved.
	31:0	TotalEnergyConsumed. Read-only,Volatile. Reset: 0000_0000h.

#MSRC001_02F0 [Protected Processor Inventory Number Control] (Core::X86::Msr::PPIN_CTL)
##Unpredictable.
	63:2	Reserved.
	1	PPIN_EN. Unpredictable. Reset: X. 0=Reading Core::X86::Msr::PPIN will cause a #GP. 1=Core::X86::Msr::PPIN is accessible using RDMSR. Once set, attempting to write 1 to Core::X86::Msr::PPIN_CTL[Lockout] will cause a #GP.
	0	Lockout. Unpredictable. Reset: X. 0=Writes to Core::X86::Msr::PPIN_CTL are permitted if PPIN_EN == 0. 1=Further Writes to Core::X86::Msr::PPIN_CTL are ignored. Description: Writing 1 to Core::X86::Msr::PPIN_CTL[Lockout] is permitted only if Core::X86::Msr::PPIN_CTL[PPIN_EN] == 0. BIOS should provide an opt-in menu to enable the user to turn on Core::X86::Msr::PPIN_CTL[PPIN_EN] for privileged inventory initialization agent to access Core::X86::Msr::PPIN. After reading Core::X86::Msr::PPIN, the privileged inventory initialization agent should write 00b followed by 01b to Core::X86::Msr::PPIN_CTL to disable further access to MSR_PPIN and prevent unauthorized modification to MSR_PPIN_CTL. Once this bit is written with 1, subsequent writes to this register are ignored, and a reset (warm or cold) is required in order to clear it, which gives BIOS the opportunity to set it again at the next boot.

#MSRC001_02F1 [Protected Processor Inventory Number] (Core::X86::Msr::PPIN)
	63:0	PPIN. Reset: Fixed,XXXX_XXXX_XXXX_XXXXh. Protected Processor Inventory Number. AccessType: ({Core::X86::Msr::PPIN_CTL[PPIN_EN] , Core::X86::Msr::PPIN_CTL[Lockout]} == 2h) ? Read,Error-on-write : Error-on-read,Error-on-write.

#MSRC001_03[00...1E] [Sample Branch From] (Core::X86::Msr::SAMP_BR_FROM)
##Read-write,Volatile. "These MSRs are paired elements of a SAMP_BR_FROM register N and SAMP_BR_TO register N. The first sample is intended to be in register 0 and the last sample in register N-1."
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n0; MSRC001_0300"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n1; MSRC001_0302"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n2; MSRC001_0304"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n3; MSRC001_0306"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n4; MSRC001_0308"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n5; MSRC001_030A"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n6; MSRC001_030C"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n7; MSRC001_030E"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n8; MSRC001_0310"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n9; MSRC001_0312"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n10; MSRC001_0314"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n11; MSRC001_0316"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n12; MSRC001_0318"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n13; MSRC001_031A"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n14; MSRC001_031C"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n15; MSRC001_031E"
	63:0	"BranchFrmOffSet. Read-write,Volatile. Reset: XXXX_XXXX_XXXX_XXXXh. The 64 bit Segment offset (RIP) of the Branch Instruction"

#MSRC001_03[01...1F] [Sample Branch To] (Core::X86::Msr::SAMP_BR_TO)
##These MSRs are paired elements of a SAMP_BR_FROM register N and SAMP_BR_TO register N. The first sample is intended to be in register 0 and the last sample in register N-1.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n0; MSRC001_0301"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n1; MSRC001_0303"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n2; MSRC001_0305"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n3; MSRC001_0307"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n4; MSRC001_0309"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n5; MSRC001_030B"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n6; MSRC001_030D"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n7; MSRC001_030F"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n8; MSRC001_0311"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n9; MSRC001_0313"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n10; MSRC001_0315"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n11; MSRC001_0317"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n12; MSRC001_0319"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n13; MSRC001_031B"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n14; MSRC001_031D"
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]_n15; MSRC001_031F"
	63:61	Reserved.
	60:0	"BranchToOffSet. Read-write,Volatile. Reset: XXXX_XXXX_XXXX_XXXXh. The 64 bit Segment offset (RIP) of the Target of the Branch Instruction."

#MSRC001_1002 [CPUID Features for CPUID Fn00000007_E[A,B]X] (Core::X86::Msr::CPUID_7_Features)
##Read-write. "Core::X86::Msr::CPUID_7_Features[63:32] provides control over values read from Core::X86::Cpuid::StructExtFeatIdEax0; Core::X86::Msr::CPUID_7_Features[31:0] provides control over values read from Core::X86::Cpuid::StructExtFeatIdEbx0."
###_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_1002
	63:30	Reserved.
	29	"SHA. Read-write. Reset: Core::X86::Cpuid::StructExtFeatIdEbx0[SHA]. See Core::X86::Cpuid::StructExtFeatIdEbx0[SHA]."
	28:25	Reserved.
	24	"CLWB: cache line write back. Read-write. Reset: Core::X86::Cpuid::StructExtFeatIdEbx0[CLWB]. See Core::X86::Cpuid::StructExtFeatIdEbx0[CLWB]."
	23	"CLFSHOPT. Read-write. Reset: Core::X86::Cpuid::StructExtFeatIdEbx0[CLFSHOPT]. See Core::X86::Cpuid::StructExtFeatIdEbx0[CLFSHOPT]."
	20	"SMAP. Read-write. Reset: Core::X86::Cpuid::StructExtFeatIdEbx0[SMAP]. See Core::X86::Cpuid::StructExtFeatIdEbx0[SMAP]."
	19	"ADX. Read-write. Reset: Core::X86::Cpuid::StructExtFeatIdEbx0[ADX]. See Core::X86::Cpuid::StructExtFeatIdEbx0[ADX]."
	18	"RDSEED. Read-write. Reset: Core::X86::Cpuid::StructExtFeatIdEbx0[RDSEED]. See Core::X86::Cpuid::StructExtFeatIdEbx0[RDSEED]."
	17:16	Reserved.
	15	"PQE. Read-write. Reset: Core::X86::Cpuid::StructExtFeatIdEbx0[PQE]. See Core::X86::Cpuid::StructExtFeatIdEbx0[PQE]."
	14:13	Reserved.
	12	"PQM. Read-write. Reset: Core::X86::Cpuid::StructExtFeatIdEbx0[PQM]. See Core::X86::Cpuid::StructExtFeatIdEbx0[PQM]."
	11	Reserved.
	10	"INVPCID. Read-write. Reset: Core::X86::Cpuid::StructExtFeatIdEbx0[INVPCID]. See Core::X86::Cpuid::StructExtFeatIdEbx0[INVPCID]."
	9	Reserved.
	8	"BMI2. Read-write. Reset: Core::X86::Cpuid::StructExtFeatIdEbx0[BMI2]. See Core::X86::Cpuid::StructExtFeatIdEbx0[BMI2]."
	7	"SMEP. Read-write. Reset: Core::X86::Cpuid::StructExtFeatIdEbx0[SMEP]. See Core::X86::Cpuid::StructExtFeatIdEbx0[SMEP]."
	6	Reserved.
	5	AVX2. Read-write. Reset: Core::X86::Cpuid::StructExtFeatIdEbx0[AVX2]. See Core::X86::Cpuid::StructExtFeatIdEbx0[AVX2].
	4	Reserved.
	3	BMI1. Read-write. Reset: Core::X86::Cpuid::StructExtFeatIdEbx0[BMI1]. See Core::X86::Cpuid::StructExtFeatIdEbx0[BMI1].
	2:1	Reserved.
	0	FSGSBASE. Read-write. Reset: Core::X86::Cpuid::StructExtFeatIdEbx0[FSGSBASE]. See Core::X86::Cpuid::StructExtFeatIdEbx0[FSGSBASE].

#MSRC001_1003 [Thermal and Power Management CPUID Features] (Core::X86::Msr::CPUID_PWR_THERM)
##Read-write. "Core::X86::Msr::CPUID_PWR_THERM provides control over values read from Core::X86::Cpuid::ThermalPwrMgmtEcx."
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_1003"
	63:1	Reserved.
	0	EffFreq. Read-write. Reset: Core::X86::Cpuid::ThermalPwrMgmtEcx[EffFreq]. See Core::X86::Cpuid::ThermalPwrMgmtEcx[EffFreq].

#MSRC001_1004 [CPUID Features for CPUID Fn00000001_E[C,D]X] (Core::X86::Msr::CPUID_Features)
##Read-write. "Core::X86::Msr::CPUID_Features[63:32] provides control over values read from Core::X86::Cpuid::FeatureIdEcx; Core::X86::Msr::CPUID_Features[31:0] provides control over values read from Core::X86::Cpuid::FeatureIdEdx."
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_1004"
	63	Reserved.
	62	"RDRAND. Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[RDRAND]. See Core::X86::Cpuid::FeatureIdEcx[RDRAND]."
	61	F16C. Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[F16C]. See Core::X86::Cpuid::FeatureIdEcx[F16C].
	59	"OSXSAVE. Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[OSXSAVE]. Modifies Core::X86::Cpuid::FeatureIdEcx[OSXSAVE] only if CR4[OSXSAVE]."
	58	"XSAVE. Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[XSAVE]. See Core::X86::Cpuid::FeatureIdEcx[XSAVE]."
	57	"AES. Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[AES]. Modifies Core::X86::Cpuid::FeatureIdEcx[AES] only if the reset value is 1."
	56	Reserved.
	55	"POPCNT. Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[POPCNT]. See Core::X86::Cpuid::FeatureIdEcx[POPCNT]."
	54	"MOVBE. Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[MOVBE]. See Core::X86::Cpuid::FeatureIdEcx[MOVBE]."
	53	"X2APIC. Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[X2APIC]. See Core::X86::Cpuid::FeatureIdEcx[X2APIC]."
	52	"SSE42. Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[SSE42]. See Core::X86::Cpuid::FeatureIdEcx[SSE42]."
	51	"SSE41. Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[SSE41]. See Core::X86::Cpuid::FeatureIdEcx[SSE41]."
	50	Reserved.
	49	PCID. Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[PCID]. See Core::X86::Cpuid::FeatureIdEcx[PCID].
	48:46	Reserved.
	45	"CMPXCHG16B. Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[CMPXCHG16B]. See Core::X86::Cpuid::FeatureIdEcx[CMPXCHG16B]."
	44	FMA. Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[FMA]. See Core::X86::Cpuid::FeatureIdEcx[FMA].
	43:42	Reserved.
	41	"SSSE3. Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[SSSE3]. See Core::X86::Cpuid::FeatureIdEcx[SSSE3]."
	40:36	Reserved.
	35	"Monitor. Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[Monitor]. Modifies Core::X86::Cpuid::FeatureIdEcx[Monitor] only if ~Core::X86::Msr::HWCR[MonMwaitDis]."
	34	Reserved.
	33	"PCLMULQDQ. Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[PCLMULQDQ]. Modifies Core::X86::Cpuid::FeatureIdEcx[PCLMULQDQ] only if the reset value is 1."
	32	SSE3. Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[SSE3]. See Core::X86::Cpuid::FeatureIdEcx[SSE3].
	31:29	Reserved.
	28	HTT. Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[HTT]. See Core::X86::Cpuid::FeatureIdEdx[HTT].
	27	Reserved.
	26	SSE2. Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[SSE2]. See Core::X86::Cpuid::FeatureIdEdx[SSE2].
	25	SSE. Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[SSE]. See Core::X86::Cpuid::FeatureIdEdx[SSE].
	24	"FXSR. Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[FXSR]. See Core::X86::Cpuid::FeatureIdEdx[FXSR]."
	23	"MMX: MMX instructions. Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[MMX]. See Core::X86::Cpuid::FeatureIdEdx[MMX]."
	22:20	Reserved.
	19	"CLFSH. Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[CLFSH]. See Core::X86::Cpuid::FeatureIdEdx[CLFSH]."
	18	Reserved.
	17	"PSE36. Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[PSE36]. See Core::X86::Cpuid::FeatureIdEdx[PSE36]."
	16	PAT. Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[PAT]. See Core::X86::Cpuid::FeatureIdEdx[PAT].
	15	CMOV. Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[CMOV]. See Core::X86::Cpuid::FeatureIdEdx[CMOV].
	14	MCA. Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[MCA]. See Core::X86::Cpuid::FeatureIdEdx[MCA].
	13	PGE. Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[PGE]. See Core::X86::Cpuid::FeatureIdEdx[PGE].
	12	"MTRR. Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[MTRR]. See Core::X86::Cpuid::FeatureIdEdx[MTRR]."
	11	"SysEnterSysExit. Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[SysEnterSysExit]. See Core::X86::Cpuid::FeatureIdEdx[SysEnterSysExit]."
	10	Reserved.
	9	"APIC. Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[APIC]. Modifies Core::X86::Cpuid::FeatureIdEdx[APIC] only if Core::X86::Msr::APIC_BAR[ApicEn]."
	8	"CMPXCHG8B. Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[CMPXCHG8B]. See Core::X86::Cpuid::FeatureIdEdx[CMPXCHG8B]."
	7	MCE. Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[MCE]. See Core::X86::Cpuid::FeatureIdEdx[MCE].
	6	PAE. Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[PAE]. See Core::X86::Cpuid::FeatureIdEdx[PAE].
	5	MSR. Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[MSR]. See Core::X86::Cpuid::FeatureIdEdx[MSR].
	4	TSC. Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[TSC]. See Core::X86::Cpuid::FeatureIdEdx[TSC].
	3	PSE. Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[PSE]. See Core::X86::Cpuid::FeatureIdEdx[PSE].
	2	DE. Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[DE]. See Core::X86::Cpuid::FeatureIdEdx[DE].
	1	VME. Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[VME]. See Core::X86::Cpuid::FeatureIdEdx[VME].
	0	FPU. Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[FPU]. See Core::X86::Cpuid::FeatureIdEdx[FPU].

#MSRC001_1005 [CPUID Features for CPUID Fn80000001_E[C,D]X] (Core::X86::Msr::CPUID_ExtFeatures)
##Read-write. "Core::X86::Msr::CPUID_ExtFeatures[63:32] provides control over values read from Core::X86::Cpuid::FeatureExtIdEcx; Core::X86::Msr::CPUID_ExtFeatures[31:0] provides control over values read from Core::X86::Cpuid::FeatureExtIdEdx."
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_1005"
	63	Reserved.
	62	"AdMskExtn. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[AdMskExtn]. See Core::X86::Cpuid::FeatureExtIdEcx[AdMskExtn]."
	61	"MwaitExtended. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[MwaitExtended]. See Core::X86::Cpuid::FeatureExtIdEcx[MwaitExtended]."
	60	"PerfCtrExtLLC. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[PerfCtrExtLLC]. See Core::X86::Cpuid::FeatureExtIdEcx[PerfCtrExtLLC]."
	59	"PerfTsc. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[PerfTsc]. See Core::X86::Cpuid::FeatureExtIdEcx[PerfTsc]."
	58	"DataBreakpointExtension. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[DataBreakpointExtension]. See Core::X86::Cpuid::FeatureExtIdEcx[DataBreakpointExtension]."
	57	Reserved.
	56	"PerfCtrExtDF. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[PerfCtrExtDF]. See Core::X86::Cpuid::FeatureExtIdEcx[PerfCtrExtDF]."
	55	"PerfCtrExtCore. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[PerfCtrExtCore]. See Core::X86::Cpuid::FeatureExtIdEcx[PerfCtrExtCore]."
	54	"TopologyExtensions. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions]. See Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions]."
	53:50	Reserved.
	49	"TCE. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[TCE]. See Core::X86::Cpuid::FeatureExtIdEcx[TCE]."
	48	FMA4. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[FMA4]. See Core::X86::Cpuid::FeatureExtIdEcx[FMA4].
	47	"LWP. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[LWP]. See Core::X86::Cpuid::FeatureExtIdEcx[LWP]."
	46	Reserved.
	45	"WDT. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[WDT]. See Core::X86::Cpuid::FeatureExtIdEcx[WDT]."
44	"SKINIT. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[SKINIT]. See Core::X86::Cpuid::FeatureExtIdEcx[SKINIT]."
	43	"XOP. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[XOP]. See Core::X86::Cpuid::FeatureExtIdEcx[XOP]."
	42	"IBS. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[IBS]. See Core::X86::Cpuid::FeatureExtIdEcx[IBS]."
	41	"OSVW. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[OSVW]. See Core::X86::Cpuid::FeatureExtIdEcx[OSVW]."
	40	"ThreeDNowPrefetch. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[ThreeDNowPrefetch]. See Core::X86::Cpuid::FeatureExtIdEcx[ThreeDNowPrefetch]."
	39	"MisAlignSse. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[MisAlignSse]. See Core::X86::Cpuid::FeatureExtIdEcx[MisAlignSse]."
	38	"SSE4A. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[SSE4A]. See Core::X86::Cpuid::FeatureExtIdEcx[SSE4A]."
	37	"ABM. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[ABM]. See Core::X86::Cpuid::FeatureExtIdEcx[ABM]."
	36	"AltMovCr8. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[AltMovCr8]. See Core::X86::Cpuid::FeatureExtIdEcx[AltMovCr8]."
	35	"ExtApicSpace. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[ExtApicSpace]. See Core::X86::Cpuid::FeatureExtIdEcx[ExtApicSpace]."
	34	"SVM. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[SVM]. See Core::X86::Cpuid::FeatureExtIdEcx[SVM]."
	33	"CmpLegacy. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[CmpLegacy]. See Core::X86::Cpuid::FeatureExtIdEcx[CmpLegacy]."
	32	"LahfSahf. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[LahfSahf]. See Core::X86::Cpuid::FeatureExtIdEcx[LahfSahf]."
	31	"ThreeDNow: 3DNow! instructions. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[ThreeDNow]. See Core::X86::Cpuid::FeatureExtIdEdx[ThreeDNow]."
	30	"ThreeDNowExt. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[ThreeDNowExt]. See Core::X86::Cpuid::FeatureExtIdEdx[ThreeDNowExt]."
	29	"LM. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[LM]. See Core::X86::Cpuid::FeatureExtIdEdx[LM]."
	28	Reserved.
	27	"RDTSCP. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[RDTSCP]. Core::X86::Cpuid::FeatureExtIdEdx[RDTSCP]."
	26	"Page1GB. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[Page1GB]. Core::X86::Cpuid::FeatureExtIdEdx[Page1GB]."
	25	"FFXSR. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[FFXSR]. See Core::X86::Cpuid::FeatureExtIdEdx[FFXSR]."
	24	"FXSR. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[FXSR]. See Core::X86::Cpuid::FeatureExtIdEdx[FXSR]."
	23	"MMX: MMX instructions. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[MMX]. See Core::X86::Cpuid::FeatureExtIdEdx[MMX]."
	22	MmxExt. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[MmxExt]. See Core::X86::Cpuid::FeatureExtIdEdx[MmxExt].
	21	Reserved.
	20	NX. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[NX]. See Core::X86::Cpuid::FeatureExtIdEdx[NX].
	19:18	Reserved.
	17	"PSE36. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[PSE36]. See Core::X86::Cpuid::FeatureExtIdEdx[PSE36]."
	16	"PAT. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[PAT]. See Core::X86::Cpuid::FeatureExtIdEdx[PAT]."
	15	"CMOV. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[CMOV]. See Core::X86::Cpuid::FeatureExtIdEdx[CMOV]."
	14	"MCA. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[MCA]. See Core::X86::Cpuid::FeatureExtIdEdx[MCA]."
	13	"PGE. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[PGE]. See Core::X86::Cpuid::FeatureExtIdEdx[PGE]."
	12	"MTRR. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[MTRR]. See Core::X86::Cpuid::FeatureExtIdEdx[MTRR]."
	11	"SysCallSysRet. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[SysCallSysRet]. See Core::X86::Cpuid::FeatureExtIdEdx[SysCallSysRet]."
	10	Reserved.
	9	"APIC. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[APIC]. See Core::X86::Cpuid::FeatureExtIdEdx[APIC]."
	8	"CMPXCHG8B. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[CMPXCHG8B]. See Core::X86::Cpuid::Featur ExtIdEdx[CMPXCHG8B]."
	7	"MCE. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[MCE]. See Core::X86::Cpuid::FeatureExtIdEdx[MCE]."
	6	"PAE. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[PAE]. See Core::X86::Cpuid::FeatureExtIdEdx[PAE]."
	5	"MSR. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[MSR]. See Core::X86::Cpuid::FeatureExtIdEdx[MSR]."
	4	"TSC. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[TSC]. See Core::X86::Cpuid::FeatureExtIdEdx[TSC]."
	3	"PSE. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[PSE]. See Core::X86::Cpuid::FeatureExtIdEdx[PSE]."
	2	DE. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[DE]. See Core::X86::Cpuid::FeatureExtIdEdx[DE].
	1	"VME. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[VME]. See Core::X86::Cpuid::FeatureExtIdEdx[VME]."
	0	"FPU. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[FPU]. See Core::X86::Cpuid::FeatureExtIdEdx[FPU]."

#MSRC001_1019 [Address Mask For DR1 Breakpoint] (Core::X86::Msr::DR1_ADDR_MASK)
##Read-write. Reset: 0000_0000_0000_0000h. Support indicated by Core::X86::Cpuid::FeatureExtIdEcx[DataBreakpointExtension].
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_1019"
	63:32	Reserved.
	31:0	AddrMask: mask for DR linear address data breakpoint DR1. Read-write. Reset: 0000_0000h. 1=Exclude bit into address compare. 0=Include bit into address compare. See Core::X86::Msr::DR1_ADDR_MASK. AddrMask[11:0] qualifies the DR1 linear address instruction breakpoint, allowing the DR1 instruction breakpoint on a range of addresses in memory.

#MSRC001_101A [Address Mask For DR2 Breakpoint] (Core::X86::Msr::DR2_ADDR_MASK)
##Read-write. Reset: 0000_0000_0000_0000h. Support indicated by Core::X86::Cpuid::FeatureExtIdEcx[DataBreakpointExtension].
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_101A"
	63:32	Reserved.
	31:0	AddrMask: mask for DR linear address data breakpoint DR2. Read-write. Reset: 0000_0000h. 1=Exclude bit into address compare. 0=Include bit into address compare. See Core::X86::Msr::DR0_ADDR_MASK. AddrMask[11:0] qualifies the DR2 linear address instruction breakpoint, allowing the DR2 instruction breakpoint on a range of addresses in memory.

#MSRC001_101B [Address Mask For DR3 Breakpoint] (Core::X86::Msr::DR3_ADDR_MASK)
##Read-write. Reset: 0000_0000_0000_0000h. Support indicated by Core::X86::Cpuid::FeatureExtIdEcx[DataBreakpointExtension].
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_101B"
	63:32	Reserved.
	31:0	AddrMask: mask for DR linear address data breakpoint DR3. Read-write. Reset: 0000_0000h. 1=Exclude bit into address compare. 0=Include bit into address compare. See Core::X86::Msr::DR0_ADDR_MASK. AddrMask[11:0] qualifies the DR3 linear address instruction breakpoint, allowing the DR3 instruction breakpoint on a range of addresses in memory.

#MSRC001_1027 [Address Mask For DR0 Breakpoints] (Core::X86::Msr::DR0_ADDR_MASK)
##Read-write. Reset: 0000_0000_0000_0000h. "Support for DR0[31:12] is indicated by Core::X86::Cpuid::FeatureExtIdEcx[DataBreakpointExtension]. See Core::X86::Msr::DR1_ADDR_MASK."
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_1027"
	63:32	Reserved.
	31:0	DR0: mask for DR0 linear address data breakpoint. Read-write. Reset: 0000_0000h. 1=Exclude bit into address compare. 0=Include bit into address compare. See Core::X86::Msr::DR1_ADDR_MASK. This field qualifies the DR0 linear address data breakpoint, allowing the DR0 data breakpoint on a range of addresses in memory. AddrMask[11:0] qualifies the DR0 linear address instruction breakpoint, allowing the DR0 instruction breakpoint on a range of addresses in memory. DR0[31:12] is only valid for data breakpoints. The legacy DR0 breakpoint function is provided by DR0[31:0] == 0000_0000h). The mask bits are active high. DR0 is always used, and it can be used in conjunction with any debug function that uses DR0.

#MSRC001_1030 [IBS Fetch Control] (Core::X86::Msr::IBS_FETCH_CTL)
##Reset: 0000_0000_0000_0000h. "See 2.1.18 [Instruction Based Sampling (IBS)]. The IBS fetch sampling engine is described as follows: •The periodic fetch counter is an internal 20-bit counter: •The periodic fetch counter[19:4] is set to IbsFetchCnt[19:4] and the periodic fetch counter[3:0] is set according to IbsRandEn when IbsFetchEn is changed from 0 to 1. •It increments for every fetch cycle that completes when IbsFetchEn == 1 and IbsFetchVal == 0. •The periodic fetch counter is undefined when IbsFetchEn == 0 or IbsFetchVal == 1. •When IbsFetchCnt[19:4] is read it returns the current value of the periodic fetch counter[19:4]. •When the periodic fetch counter reaches {IbsFetchMaxCnt[19:4],0h} and the selected instruction fetch completes or is aborted: •IbsFetchVal is set to 1. •Drivers can't assume that IbsFetchCnt[19:4] is 0 when IbsFetchVal == 1. •The status of the operation is written to the IBS fetch registers (this register, Core::X86::Msr::IBS_FETCH_LINADDR and Core::X86::Msr::IBS_FETCH_PHYSADDR). •An interrupt is generated as specified by Core::X86::Msr::IBS_CTL. The interrupt service routine associated with this interrupt is responsible for saving the performance information stored in IBS execution registers."
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_1030"
	63:59	Reserved.
	58	IbsFetchL2Miss: L2 cache miss for the sampled fetch. Read-only,Volatile. Reset: 0. 1=The instruction fetch missed in the L2 Cache. Qualified by (IbsFetchComp == 1).
	57	IbsRandEn: random instruction fetch tagging enable. Read-write. Reset: 0. 0=Bits[3:0] of the fetch counter are set to 0h when IbsFetchEn is set to start the fetch counter. 1=Bits[3:0] of the fetch counter are randomized when IbsFetchEn is set to start the fetch counter.
	56	IbsL2TlbMiss: instruction cache L2TLB miss. Read-only,Volatile. Reset: 0. 1=The instruction fetch missed in the L2 TLB.
	55	IbsL1TlbMiss: instruction cache L1TLB miss. Read-only,Volatile. Reset: 0. 1=The instruction fetch missed in the L1 TLB.
	54:53	IbsL1TlbPgSz: instruction cache L1TLB page size. Read-only,Volatile. Reset: 0h. Indicates the page size of the translation in the L1 TLB. This field is only valid if IbsPhyAddrValid == 1.
ValidValues:
0h 4 KB
1h 2 MB
2h 1 GB
3h Reserved.
ValidValuesEnd
	52	IbsPhyAddrValid: instruction fetch physical address valid. Read-only,Volatile. Reset: 0. 1=The physical address in Core::X86::Msr::IBS_FETCH_PHYSADDR and the IbsL1TlbPgSz field are valid for the instruction fetch.
	51	IbsIcMiss: instruction cache miss. Read-only,Volatile. Reset: 0. 1=The instruction fetch missed in the instruction cache.
	50	IbsFetchComp: instruction fetch complete. Read-only,Volatile. Reset: 0. 1=The instruction fetch completed and the data is available for use by the instruction decoder.
	49	IbsFetchVal: instruction fetch valid. Read,Write-0-only,Volatile. Reset: 0. 1=New instruction fetch data available. When this bit is set, the fetch counter stops counting and an interrupt is generated as specified by Core::X86::Msr::IBS_CTL. This bit must be cleared for the fetch counter to start counting. When clearing this bit, software can write 0000h to IbsFetchCnt[19:4] to start the fetch counter at IbsFetchMaxCnt[19:4].
	48	IbsFetchEn: instruction fetch enable. Read-write. Reset: 0. 1=Instruction fetch sampling is enabled.
	47:32	IbsFetchLat: instruction fetch latency. Read-only,Volatile. Reset: 0000h. Indicates the number of clock cycles from when the instruction fetch was initiated to when the data was delivered to the core. If the instruction fetch is abandoned before the fetch completes, this field returns the number of clock cycles from when the instruction fetch was initiated to when the fetch was abandoned.
	31:16	IbsFetchCnt[19:4]. Read-write,Volatile. Reset: 0000h. Provides Read/Write access to bits[19:4] of the periodic fetch counter. Programming this field to a value greater than or equal to IbsFetchMaxCnt[19:4] results in undefined behavior.
	15:0	IbsFetchMaxCnt[19:4]. Read-write. Reset: 0000h. Specifies bits[19:4] of the maximum count value of the periodic fetch counter. Programming this field to 0000h and setting IbsFetchEn results in undefined behavior. Bits[3:0] of the maximum count are always 0000b.

#MSRC001_1031 [IBS Fetch Linear Address] (Core::X86::Msr::IBS_FETCH_LINADDR)
##Read-write,Volatile. Reset: 0000_0000_0000_0000h. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_1031"
	63:0	IbsFetchLinAd: instruction fetch linear address. Read-write,Volatile. Reset: 0000_0000_0000_0000h. Provides the linear address in canonical form for the tagged instruction fetch.

#MSRC001_1032 [IBS Fetch Physical Address] (Core::X86::Msr::IBS_FETCH_PHYSADDR)
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_1032"
	63:48	Reserved.
	47:0	"IbsFetchPhysAd: instruction fetch physical address. Read-write,Volatile. Reset: 0000_0000_0000h. Provides the physical address for the tagged instruction fetch. The lower 12 bits are not modified by address translation, so they are always the same as the linear address. This field contains valid data only if Core::X86::Msr::IBS_FETCH_CTL[IbsPhyAddrValid] is asserted."

#MSRC001_1033 [IBS Execution Control] (Core::X86::Msr::IBS_OP_CTL)
##Reset: 0000_0000_0000_0000h. "See 2.1.18 [Instruction Based Sampling (IBS)]. The IBS execution sampling engine is described as follows for IbsOpCntCtl == 1. If IbsOpCntCtl == 1n then references to ""periodic op counter"" mean ""periodic cycle counter"". •The periodic op counter is an internal 27-bit counter: •It is set to IbsOpCurCnt[26:0] when IbsOpEn is changed from 0 to 1. •It increments every dispatched macro-op when IbsOpEn == 1 and IbsOpVal == 0. •The periodic op counter is undefined when IbsOpEn == 0 or IbsOpVal == 1. •When IbsOpCurCnt[26:0] is read then it returns the current value of the periodic op counter[26:0]. •When the periodic op counter reaches IbsOpMaxCnt: •The next dispatched op is tagged if IbsOpCntCtl == 1. A valid op in the next dispatched line is tagged if IbsOpCntCtl == 0. See IbsOpCntCtl. •The periodic op counter[26:7] = 0; bits[6:0] is randomized by hardware. •The periodic op counter is not modified when a tagged op is flushed. •When a tagged op is retired: •IbsOpVal is set to 1. •Drivers can't assume that IbsOpCurCnt is 0 when IbsOpVal == 1. •The status of the operation is written to the IBS execution registers (this register, Core::X86::Msr::IBS_OP_RIP, Core::X86::Msr::IBS_OP_DATA, Core::X86::Msr::IBS_OP_DATA2, Core::X86::Msr::IBS_OP_DATA3, Core::X86::Msr::IBS_DC_LINADDR and Core::X86::Msr::IBS_DC_PHYSADDR). •An interrupt is generated as specified by Core::X86::Msr::IBS_CTL. The interrupt service routine associated with this interrupt is responsible for saving the performance information stored in IBS execution registers."
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_1033"
	63:59	Reserved.
	58:32	"IbsOpCurCnt[26:0]: periodic op counter current count. Read-write,Volatile. Reset: 000_0000h. Returns the current value of the periodic op counter."
	31:27	Reserved.
	26:20	IbsOpMaxCnt[26:20]: periodic op counter maximum count. Read-write. Reset: 00h. See IbsOpMaxCnt[19:4].
	19	"IbsOpCntCtl: periodic op counter count control. Read-write. Reset: 0. 0=Count clock cycles; a 1-of-4 round- robin counter selects an op in the next dispatch line; if the op pointed to by the round-robin counter is invalid, then the next younger valid op is selected. 1=Count dispatched ops; when a roll-over occurs, the counter is preloaded with a pseudorandom 7-bit value between 1 and 127."
	18	"IbsOpVal: op sample valid. Read-write,Volatile. Reset: 0. 1=New instruction execution data available; the periodic op counter is disabled from counting. An interrupt may be generated when this bit is set as specified by Core::X86::Msr::IBS_CTL[LvtOffset]."
	17	IbsOpEn: op sampling enable. Read-write. Reset: 0. 1=Instruction execution sampling enabled.
	16	Reserved.
	15:0	"IbsOpMaxCnt[19:4]: periodic op counter maximum count. Read-write. Reset: 0000h. IbsOpMaxCnt[26:0] = {IbsOpMaxCnt[26:20], IbsOpMaxCnt[19:4], 0000b}. Specifies maximum count value of the periodic op counter. Bits [3:0] of the maximum count are always 0000b."
ValidValues:
0008h-000h	Reserved.
FFFFh-0009h	<Value> *16 Ops.
ValidValuesEnd

#MSRC001_1034 [IBS Op RIP] (Core::X86::Msr::IBS_OP_RIP)
##Read-write,Volatile. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_1034"
	63:0	IbsOpRip. Read-write,Volatile. Reset: 0000_0000_0000_0000h. 64-bit Segment offset (RIP) of the instruction that contains the tagged op.

#MSRC001_1035 [IBS Op Data] (Core::X86::Msr::IBS_OP_DATA)
##Read-write,Volatile. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_1035"
	63:41	Reserved.
	40	IbsOpMicrocode. Read-write,Volatile. Reset: 0. 1=Tagged operation from microcode.
	39	IbsOpBrnFuse: fused branch op. Read-write,Volatile. Reset: 0. 1=Tagged operation was a fused branch op. Support indicated by Core::X86::Cpuid::IbsIdEax[OpBrnFuse].
	38	IbsRipInvalid: RIP is invalid. Read-write,Volatile. Reset: 0. 1=Tagged operation RIP is invalid. Support indicated by Core::X86::Cpuid::IbsIdEax[RipInvalidChk].
	37	IbsOpBrnRet: branch op retired. Read-write,Volatile. Reset: 0. 1=Tagged operation was a branch op that retired.
	36	IbsOpBrnMisp: mispredicted branch op. Read-write,Volatile. Reset: 0. 1=Tagged operation was a branch op that was mispredicted. Qualified by IbsOpBrnRet == 1.
	35	IbsOpBrnTaken: taken branch op. Read-write,Volatile. Reset: 0. 1=Tagged operation was a branch op that was taken. Qualified by IbsOpBrnRet == 1.
	34	IbsOpReturn: return op. Read-write,Volatile. Reset: 0. 1=Tagged operation was return op. Qualified by "(IbsOpBrnRet == 1)."
	33:32	Reserved.
	31:16	IbsTagToRetCtr: op tag to retire count. Read-write,Volatile. Reset: 0000h. This field returns the number of cycles from when the op was tagged to when the op was retired. This field is equal to IbsCompToRetCtr when the tagged op is a NOP.
	15:0	IbsCompToRetCtr: op completion to retire count. Read-write,Volatile. Reset: 0000h. This field returns the number of cycles from when the op was completed to when the op was retired.

#MSRC001_1036 [IBS Op Data 2] (Core::X86::Msr::IBS_OP_DATA2)
##Reset: 0000_0000_0000_0000h. Data is only valid for load operations that miss both the L1 data cache and the L2 cache. If a load operation crosses a
cache line boundary, the data returned in this register is the data for the access to the lower cache line.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_1036"
	63:5	Reserved.
	4	RmtNode: IBS request destination node. Read-write,Volatile. Reset: 0. 0=The request is serviced by the NB in the same node as the core. 1=The request is serviced by the NB in a different node than the core. Valid when NbIbsReqSrc is non-zero.
	3	Reserved.
	2:0	DataSrc: northbridge IBS request data source. Read-write. Reset: 0h.
ValidValues:
0h	No valid status.
1h	Reserved.
2h	Cache: data returned from shared L3, other L2 on same CCX or other core's cache trough same node.
3h	DRAM: data returned from DRAM.
4h	Cache: other core's cache through remote node.
6h-5h	Reserved.
7h	Other; data returned from MMIO/Config/PCI/APIC.
ValidValuesEnd

#MSRC001_1037 [IBS Op Data 3] (Core::X86::Msr::IBS_OP_DATA3)
##Read-write,Volatile. Reset: 0000_0000_0000_0000h. If a load or store operation crosses a 256-bit boundary, the data returned in this register is the data for the access to the data below the 256-bit boundary.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_1037"
	63:48	IbsTlbRefillLat: L1 DTLB refill latency. Read-write,Volatile. Reset: 0000h. The number of cycles from when a L1 DTLB refill is triggered by a tagged op to when the L1 DTLB fill has been completed.
	47:32	IbsDcMissLat: data cache miss latency. Read-write,Volatile. Reset: 0000h. Indicates the number of clock cycles from when a miss is detected in the data cache to when the data was delivered to the core. The value returned by this counter is not valid for data cache writes or prefetch instructions.
	31:26	IbsOpDcMissOpenMemReqs: outstanding memory requests on DC fill. Read-write,Volatile. Reset: 00h. The number of allocated, valid DC MABs when the MAB corresponding to a tagged DC miss op is deallocated. Includes the MAB allocated by the sampled op. 00000b=No information provided.
	25:22	IbsOpMemWidth: load/store size in bytes. Read-write,Volatile. Reset: 0h. Report the number of bytes the load or store is attempting to access.
ValidValues:
0h No information provided.
1h Byte.
2h Word.
3h DW.
4h QW.
5h OW.
Fh-6h Reserved.
ValidValuesEnd
	21	IbsSwPf: software prefetch. Read-write,Volatile. Reset: 0. 1=The op is a software prefetch.
	20	IbsL2Miss: L2 cache miss for the sampled operation. Read-write,Volatile. Reset: 0. 1=The operation missed in the L2, regardless of whether the op initiated the request to the L2.
	19	Reserved.
	18	IbsDcPhyAddrValid: data cache physical address valid. Read-write,Volatile. Reset: 0. 1=The physical address in Core::X86::Msr::IBS_DC_PHYSADDR is valid for the load or store operation.
	17	IbsDcLinAddrValid: data cache linear address valid. Read-write,Volatile. Reset: 0. 1=The linear address in Core::X86::Msr::IBS_DC_LINADDR is valid for the load or store operation.
	16	DcMissNoMabAlloc: DC miss with no MAB allocated. Read-write,Volatile. Reset: 0. 1=The tagged load or store operation hit on an already allocated MAB.
	15	IbsDcLockedOp: locked operation. Read-write,Volatile. Reset: 0. 1=Tagged load or store operation is a locked operation.
	14	IbsDcUcMemAcc: UC memory access. Read-write,Volatile. Reset: 0. 1=Tagged load or store operation accessed uncacheable memory.
	13	IbsDcWcMemAcc: WC memory access. Read-write,Volatile. Reset: 0. 1=Tagged load or store operation accessed write combining memory.
	12:9	Reserved.
	8	IbsDcMisAcc: misaligned access. Read-write,Volatile. Reset: 0. 1=The tagged load or store operation crosses a 256-bit address boundary.
	7	IbsDcMiss: data cache miss. Read-write,Volatile. Reset: 0. 1=The cache line used by the tagged load or store was not present in the data cache.
	6	Reserved.
	5:4	IbsDcPgSz: data cache page size. Read-write,Volatile. Reset: 0h. Page size information is only availabe when IbsDcPhyAddrValid is set.
ValidValues:
0h 4 KB
1h 2 MB
2h 1 GB
3h Reserved.
ValidValuesEnd
	3	IbsDcL2TlbMiss: data cache L2TLB miss. Read-write,Volatile. Reset: 0. 1=The physical address for the tagged load or store operation was not present in the data cache L2TLB.
	2	IbsDcL1tlbMiss: data cache L1TLB miss. Read-write,Volatile. Reset: 0. 1=The physical address for the tagged load or store operation was not present in the data cache L1TLB.
	1	IbsStOp: store op. Read-write,Volatile. Reset: 0. 1=Tagged operation is a store operation.
	0	IbsLdOp: load op. Read-write,Volatile. Reset: 0. 1=Tagged operation is a load operation.

#MSRC001_1038 [IBS DC Linear Address] (Core::X86::Msr::IBS_DC_LINADDR)
##Read-write,Volatile. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_1038"
	63:0	IbsDcLinAd. Read-write,Volatile. Reset: 0000_0000_0000_0000h. Provides the linear address in canonical form for the tagged load or store operation. This field contains valid data only if Core::X86::Msr::IBS_OP_DATA3[IbsDcLinAddrValid] is asserted.

#MSRC001_1039 [IBS DC Physical Address] (Core::X86::Msr::IBS_DC_PHYSADDR)
##Read-write,Volatile. Reset: 0000_0000_0000_0000h.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_1039"
	63:48	Reserved.
	47:0	IbsDcPhysAd: load or store physical address. Read-write,Volatile. Reset: 0000_0000_0000h. Provides the physical address for the tagged load or store operation. The lower 12 bits are not modified by address translation, so they are always the same as the linear address. This field contains valid data only if Core::X86::Msr::IBS_OP_DATA3[IbsDcPhyAddrValid] is asserted.

#MSRC001_103A [IBS Control] (Core::X86::Msr::IBS_CTL)
##Read,Error-on-write.
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_103A"
	63:9	Reserved.
	8	LvtOffsetVal: local vector table offset valid. Read,Error-on-write. Reset: X.
	7:4	Reserved.
	3:0	LvtOffset: local vector table offset. Read,Error-on-write. Reset: Xh.

#MSRC001_103B [IBS Branch Target Address] (Core::X86::Msr::BP_IBSTGT_RIP)
##Read-write,Volatile. Reset: 0000_0000_0000_0000h. Support for this register indicated by Core::X86::Cpuid::IbsIdEax[BrnTrgt].
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_103B"
	63:0	"IbsBrTarget. Read-write,Volatile. Reset: 0000_0000_0000_0000h. The logical address in canonical form for the branch target. Contains a valid target if non-0. Qualified by Core::X86::Msr::IBS_OP_DATA[IbsOpBrnRet] == 1."

#MSRC001_103C [IBS Fetch Control Extended] (Core::X86::Msr::IC_IBS_EXTD_CTL)
##Read-only,Volatile. Reset: 0000_0000_0000_0000h. Support for this register indicated by Core::X86::Cpuid::IbsIdEax[IbsFetchCtlExtd].
###"_ccd[7:0]_lthree0_core[7:0]_thread[1:0]; MSRC001_103C"
	63:16	Reserved.
	15:0	IbsItlbRefillLat: ITLB Refill Latency for the sampled fetch, if there is a reload. Read-only,Volatile. Reset: 0000h. The number of cycles when the fetch engine is stalled for an ITLB reload for the sampled fetch. If there is no reload, the latency is 0.
